#+TITLE: init
#+PROPERTY: header-args :tangle init.el
#+startup: content

Some of the awesome configurations used as reference:

+ james cash ::  [[file:~/repos/james-cash-dotfiles/emacs.d/eshell][file:~/repos/james-cash-dotfiles/emacs.d/eshell]]
+ prot :: [[file:~/repos/prot-dotfiles/emacs/.emacs.d/emacs-init.org]]
+ Doom Emacs
+ Emacs from scratch series :: [[file:~/repos/emacs-from-scratch/Emacs.org]]

* personal info

#+begin_src emacs-lisp

  (setq user-full-name "Jigang Li"
        user-mail-address "ljg16654@sjtu.edu.cn")
#+end_src
n
#+RESULTS:
: Ljg16654@sjtu.edu.cn

* straight.el

#+begin_src emacs-lisp

  ;; each use-package form also invoke straight.el to install the package
  (setq straight-use-package-by-default t)
#+end_src

#+begin_src emacs-lisp

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

#+end_src

then, install =use-package= with straight.el:

#+begin_src emacs-lisp

  (straight-use-package 'use-package)
#+end_src

* basic

** common functionallity

*** copy filename

From Doom Emacs. Naming is altered to be consistent with Emacs terms
(yank -> save-to-king-ring).

#+begin_src emacs-lisp

  (defun +default/save-to-king-ring-buffer-filename ()
    "Copy the current buffer's path to the kill ring."
    (interactive)
    (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
        (message (kill-new (abbreviate-file-name filename)))
      (error "Couldn't find filename in current buffer")))

  (global-set-key (kbd "C-c k f")  #'+default/save-to-king-ring-buffer-filename)
#+end_src

#+RESULTS:
: +default/save-to-king-ring-buffer-filename

* theme, font

[[https://stackoverflow.com/questions/21033270/resizing-echoarea-of-emacsclient][related issue on wired space at bottom]]
#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "iosevka" :height 135)
#+end_src

#+RESULTS:
: t
#+begin_src emacs-lisp
  (use-package anti-zenburn-theme
    :defer t)
  (use-package solarized-theme
    :defer t
    :config
    (progn
      (setq solarized-use-variable-pitch nil)))
  (use-package spacemacs-theme
    :defer t)

#+end_src

#+RESULTS:
: t

* searching

Sometimes, when =lsp= doesn't work for some reasons (for example,
dependencies are not met on the machine and thus =cmake= cannot be
performed), it proves necessary to find definitions and references
through manual search.

Currently I'm experimenting with all kinds of choices in order to find

- best approach to finding symbol under cursor in project.
- difference between =project.el= (shipped with Emacs) and =projectile=.

** rg

In default bindings of =rg=, =C-c s= spawns a transient menu
similar to that of =magit=.
=s-f= is also bound to =rg-menu=.

Severals notes on the manual pages:
- =ripgrep= has it own configuration which is not encourage by =rg= as it
may easily bring about malfunction due to carelessness.
- The variable =rg-ignore-case= can be customized for case sensitivity.
- r :: =rg=. Interprets _query_ string as regexp.
- t :: =rg-literal=. Interprets _query_ string literally.
- p :: =rg-project=.
- d :: =rg-dwim=. Search in project by default while search in
  file/directory can be called with universal arguments.

The package also features isearch integration. While I'm considering
about migration from ivy to swiper, the integration is appended to
read later at the moment.

#+begin_src elisp

  (use-package rg
    :config
    (progn
      (rg-enable-default-bindings))
    :bind
    ("s-f" . rg-menu))

  ;; seems to be dependency for projectile-ripgrep
  (use-package ripgrep) 
#+end_src

#+RESULTS:

** ag

#+begin_src emacs-lisp

  (use-package ag)
#+end_src

#+RESULTS:

* keybinding

[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][mastering key bindings emacs]]
/Function/ and /navigation/ keys, i.e. keys including F-keys, arrow keys
and home row keys, should be wrapped with =<= and =>=.

** general.el

For examples, see [[file:../org-roam/20210113022951-general_el_define_keybinding.org][general.el define keybinding]].

#+begin_src elisp

  (use-package general)
#+end_src

#+RESULTS:

** evil
#+begin_src emacs-lisp

  (use-package evil)
  (use-package evil-escape
    :config
    (progn
      (setq-default evil-escape-key-sequence "jk")
      (evil-escape-mode)))

  (global-set-key (kbd "H-e") #'evil-mode)
#+end_src

#+RESULTS:
: evil-mode

* window and buffer

** window rules and management
*** monocle-window

From prot's dotEmacs. Defines a monocole layout similar to Tiling
window managers.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defvar prot/window-configuration nil
    "Current window configuration.
Intended for use by `prot/window-monocle'.")

  (define-minor-mode prot/window-single-toggle
    "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
    :lighter " [M]"
    :global nil
    (if (one-window-p)
        (when prot/window-configuration
          (set-window-configuration prot/window-configuration))
      (setq prot/window-configuration (current-window-configuration))
      (delete-other-windows)))
  :bind ("s-s" . prot/window-single-toggle))
#+end_src

#+RESULTS:
: prot/window-single-toggle

*** display-buffer-alist

[[https://protesilaos.com/dotemacs/#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][prot window rules]]
[[info:emacs#Window Choice][info:emacs#Window Choice]]

#+begin_src emacs-lisp

  (setq display-buffer-alist
        '(
          ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2)
           (window-parameters . ((no-other-window . t))))
          ;; bottom side window
          ("\\*\\(Completions\\|Embark Collect Live\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; left side window
          ("\\*Help.*"
           (display-buffer-in-side-window)
           (window-width . 0.20)       ; See the :hook
           (side . left)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; right side window
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 0)
           (window-parameters
            . ((mode-line-format
                . (" "
                   mode-line-buffer-identification)))))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ;; bottom buffer (NOT side window)
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-at-bottom)
           (window-parameters . ((no-other-window . t))))
          ("\\*WordNet*"
           (display-buffer-in-side-window
            (window-height . 0.5)
            (side . top)
            (slot . 3)))
          ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . 0.2)
           ;; (mode . '(eshell-mode shell-mode))
           )))

  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (global-set-key (kbd "s-q") #'window-toggle-side-windows)
  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)
#+end_src

#+RESULTS:
| visual-line-mode |

*** window-layout history

Waiting for confirmation before tangling.

#+begin_src emacs-lisp :tangle nil

  (use-package winner
    :hook (after-init-hook . winner-mode)
    :bind (("s-S-<left>" . winner-redo)
           ("s-S-<right>" . winner-undo)))

#+end_src

#+RESULTS:
: winner-undo

** buffer switch

#+begin_src emacs-lisp

  ;; between buffers

  (global-set-key (kbd "s-i") #'ibuffer)
  ;; (global-set-key (kbd "s-o") #'switch-to-buffer)
  (global-set-key (kbd "s-<left>") #'previous-buffer)
  (global-set-key (kbd "s-<right>") #'next-buffer)
  (global-set-key (kbd "C-x <return> r")
                  ;; originally bound to
                  ;; revert-buffer-with-coding-system
                  #'revert-buffer)

  ;; inside a tab

  (setq aw-keys
        (list ?a ?s ?d ?f ?j ?k ?l))

  (global-set-key (kbd "s-j") #'other-window)
  (global-set-key (kbd "s-k") #'(lambda () (interactive)
                                  (other-window -1)))
  (global-set-key (kbd "H-s") #'delete-other-windows)

  ;; new tab starts with scratch buffer

  (setq tab-bar-new-tab-choice "*scratch*")

#+end_src

#+RESULTS:
: *scratch*

** tab-bar

#+begin_src elisp

  (use-package tab-bar
    :init
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
    (setq tab-bar-close-tab-select 'recent)
    (setq tab-bar-new-tab-choice t)
    (setq tab-bar-new-tab-to 'right)
    (setq tab-bar-position nil)
    (setq tab-bar-show nil)
    (setq tab-bar-tab-hints nil)
    (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
    :config
    (tab-bar-mode -1)
    (tab-bar-history-mode -1))

  (defun prot-tab--tab-bar-tabs ()
    "Return a list of `tab-bar' tabs, minus the current one."
    (mapcar (lambda (tab)
              (alist-get 'name tab))
            (tab-bar--tabs-recent)))

  (defun prot-tab-select-tab-dwim ()
      "Do-What-I-Mean function for getting to a `tab-bar' tab.
  If no other tab exists, create one and switch to it.  If there is
  one other tab (so two in total) switch to it without further
  questions.  Else use completion to select the tab to switch to."
      (interactive)
      (let ((tabs (prot-tab--tab-bar-tabs)))
        (cond ((eq tabs nil)
               (tab-new))
              ((eq (length tabs) 1)
               (tab-next))
              (t
               (tab-bar-switch-to-tab
                (completing-read "Select tab: " tabs nil t))))))

  (defun prot-tab-tab-bar-toggle ()
    "Toggle `tab-bar' presentation."
    (interactive)
    (if (bound-and-true-p tab-bar-mode)
        (progn
          (setq tab-bar-show nil)
          (tab-bar-mode -1))
      (setq tab-bar-show t)
      (tab-bar-mode 1)))

  (defconst tab-leader "s-<tab>")

  (general-create-definer tab-leader-def
    :prefix tab-leader)

  ;; global hyper leader def
  (tab-leader-def
    "n" 'tab-bar-new-tab
    "r" 'tab-bar-rename-tab
    "k" 'tab-bar-close-tab
    "t" 'prot-tab-tab-bar-toggle
    "<tab>" 'prot-tab-select-tab-dwim) 

  (global-set-key (kbd "C-x t t") #'prot-tab-select-tab-dwim)
#+end_src

#+RESULTS:
: prot-tab-select-tab-dwim

** kill buffer
#+begin_src emacs-lisp

  (defun prot-simple-kill-buffer-current (&optional arg)
    "Kill current buffer or abort recursion when in minibuffer.
  With optional prefix ARG (\\[universal-argument]) delete the
  buffer's window as well."
    (interactive "P")
    (if (minibufferp)
        (abort-recursive-edit)
      (kill-buffer (current-buffer)))
    (when (and arg
               (not (one-window-p)))
      (delete-window)))

  (global-set-key (kbd "s-c") #'prot-simple-kill-buffer-current)
  (global-set-key (kbd "s-C") #'(lambda ()
                                  (interactive)
                                  (prot-simple-kill-buffer-current 1)))

#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (prot-simple-kill-buffer-current 1) |

** buffer naming

#+begin_src emacs-lisp

  (global-set-key (kbd "C-c b r") #'rename-buffer)
#+end_src

#+RESULTS:
: rename-buffer

* movement

In buffer or across buffers.
** avy
#+begin_src emacs-lisp

  (use-package avy
    :bind (("M-l" . avy-goto-line)))

  (global-unset-key (kbd "C-'"))
  (global-set-key (kbd "C-'") #'avy-goto-char-2)
  (global-set-key (kbd "H-d") #'avy-goto-char-2)
  (global-set-key (kbd "H-f") #'avy-goto-char)

#+end_src

#+RESULTS:
: langou/goto-config

** frequently visited files

#+begin_src emacs-lisp

  (defun langou/goto-config ()
    "go to personal configuration of emacs"
    (interactive)
    (find-file "~/vanilla/init.org"))

  (global-set-key (kbd "C-c f p") #'langou/goto-config)

#+end_src

* project

** eyebrowse

|-----------+-----------------------|
| key       | Doom Emacs equivalent |
|-----------+-----------------------|
| C-c C-w c | SPC TAB n             |
| C-c C-w . | ?                     |
| C-c C-w , | SPC TAB r             |
| M-<num>   | M-<num>               |
|-----------+-----------------------|

The shortkeys conflict with org-refile. Since I'm now using EXWM and
considering to use tab-bar-mode for managment of window layout,
tangling is currently disabled.

#+begin_src emacs-lisp :tangle nil

  (use-package eyebrowse
    :diminish eyebrowse-mode
    :config (progn
              (define-key eyebrowse-mode-map (kbd "M-1") 'eyebrowse-switch-to-window-config-1)
              (define-key eyebrowse-mode-map (kbd "M-2") 'eyebrowse-switch-to-window-config-2)
              (define-key eyebrowse-mode-map (kbd "M-3") 'eyebrowse-switch-to-window-config-3)
              (define-key eyebrowse-mode-map (kbd "M-4") 'eyebrowse-switch-to-window-config-4)
              (eyebrowse-mode t)
              (setq eyebrowse-new-workspace t)))
#+end_src

#+RESULTS:
: t

** version control

#+begin_src emacs-lisp

  (use-package magit
    :bind (("C-c g" . magit))
  )
#+end_src

#+RESULTS:
: magit

** projectile
#+begin_src emacs-lisp
(use-package projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

#+RESULTS:
: projectile-command-map

* completion

** helm

*** setup

#+begin_src emacs-lisp

  (use-package helm
    :config
    (progn
      (helm-mode 1)
      ))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp

  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "s-o") #'helm-buffers-list)
  (global-set-key (kbd "s-O") #'helm-recentf)
  (global-set-key (kbd "M-i") #'helm-imenu)
  (global-set-key (kbd "C-h a") #'helm-apropos)
  (global-set-key (kbd "s-<return>") #'helm-filtered-bookmarks)

#+end_src

#+RESULTS:
: helm-filtered-bookmarks

*** helm extensions

#+begin_src emacs-lisp

   (use-package helm-projectile
     :config
     (progn
       (helm-projectile-on)
       ))

  (global-set-key (kbd "H-SPC") #'helm-projectile)
#+end_src

#+RESULTS:
: helm-projectile

[[https://www.manueluberti.eu/emacs/2020/06/13/helm-wordnut/][blog post on helm-wordnut]]
see [[*window rules and management]] for configuration of relevent windows.

#+begin_src emacs-lisp

  (straight-use-package
   '(helm-wordnut :host github :repo "emacs-helm/helm-wordnut"))

  (defun helm-wordnet-at-point ()
    "Use `helm-wordnut--persistent-action' to define word at point.
  When the region is active, define the marked phrase."
    (interactive)
    ;; the extraction of word is copied from
    ;; package define-word
    (let ((word
           (cond
            ((eq major-mode 'pdf-view-mode)
             (car (pdf-view-active-region-text)))
            ((use-region-p)
             (buffer-substring-no-properties
              (region-beginning)
              (region-end)))
            (t
             (substring-no-properties
              (thing-at-point 'word))))))
      (helm-wordnut--persistent-action word)))

  (global-set-key (kbd "s-K") #'helm-wordnut)
  (global-set-key (kbd "s-L") #'helm-wordnet-at-point)

#+end_src

#+RESULTS:
: helm-wordnet-at-point

  ,#+RESULTS:
  : t

#+begin_src emacs-lisp

    (use-package helm-swoop)
    (global-unset)
    (global-set-key (kbd "C-s") #'helm-swoop)

#+end_src

** ivy, swiper and counsel

#+begin_src emacs-lisp :tangle nil

(use-package ivy
  :config
  (setq ivy-use-virtual-buffers t
	enable-recursive-minibuffers t)
  :bind (("C-s" . swiper)
	 ("C-c C-r" . ivy-resume)
	 ("M-x" . counsel-M-x)
	 ("C-x C-f" . counsel-find-file)))

(ivy-mode 1)
(define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)

#+end_src

** prescient.el

#+begin_src emacs-lisp :tangle nil

  (use-package prescient)
  (use-package ivy-prescient
    :after counsel
    :config
    (ivy-prescient-mode 1)
    (prescient-persist-mode 1))


#+end_src

#+RESULTS:
: t

** embark, orderless and marginalia

#+begin_src emacs-lisp

  (use-package orderless
    :ensure t
    :init (icomplete-mode)		; optional but recommended!
    :custom (completion-styles '(orderless)))

#+end_src

#+RESULTS:

#+begin_src emacs-lisp

    (use-package embark)
#+end_src

#+RESULTS:

** yasnippet
The snippets are currently stored in DOOMDIR and I may move them to somewhere else later.
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (progn
      (setq yas-snippet-dirs
	     (list "~/.doom.d/snippets"))
      (yas-global-mode)))
#+end_src
#+RESULTS:
: t
** which key
#+begin_src emacs-lisp
  (use-package which-key
    ;; :init (which-key-mode)
    :config
    (setq which-key-idle-delay 0.3))
#+end_src

#+RESULTS:
: t


enhance ivy with ivy-rich: 
#+begin_src emacs-lisp :tangle nil
  (use-package ivy-rich
    :config (ivy-rich-mode +1))
#+end_src

#+RESULTS:
: t

* dired

*** basic

#+begin_src emacs-lisp

  (use-package dired
    :straight nil
    :ensure nil
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-AGFhlv --group-directories-first --time-style=long-iso")
    (setq dired-dwim-target t))

#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp

  (add-hook 'dired-mode
            #'(lambda ()
                (progn
                  (dired-hide-details-mode +1))))
#+end_src

#+RESULTS:
| lambda | nil | (progn (dired-hide-details-mode 1)) |

*** keybinding

The default '^' for =dired-up-directory= feels a bit clumsy.  For such
reason, ';' is binded to the same function in dired-mode using
general.el.

#+begin_src emacs-lisp

  (general-define-key
   :keymaps 'dired-mode-map
   ";" #'dired-up-directory)
#+end_src

#+RESULTS:

*** TODO improve
- hide-detail not working
- working with compress files
- dired-subtree
- pipe to shell, group operation
- filtering

#+begin_src emacs-lisp

  (use-package dired-subtree
    :after dired
    :config
    (progn
      (setq dired-subtree-use-backgrounds nil)
      )
    :bind
    (:map dired-mode-map
          ("<tab>" . dired-subtree-toggle)
          ("C-<tab>" . dired-subtree-cycle)
          ))
#+end_src

#+RESULTS:
: dired-subtree-cycle

#+begin_src emacs-lisp

  (use-package peep-dired
    :bind
    (:map dired-mode-map
     ("`" . peep-dired)
     ))
#+end_src

#+RESULTS:
: peep-dired

* org

#+begin_src emacs-lisp

  (use-package org
    :config
    (progn
      (setq org-ellipsis " ▾"
            org-hide-emphasis-markers t
            org-imenu-depth 7
            )
      (local-unset-key (kbd "C-'"))
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))))
#+end_src

#+RESULTS:
: t
** appearance

#+RESULTS:
| org-indent-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | turn-on-org-cdlatex | (lambda nil (org-bullets-mode 1)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |

#+begin_src emacs-lisp

(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(add-hook 'org-mode-hook #'org-indent-mode)
#+end_src

** refile
#+begin_src emacs-lisp
  (setq +personal-org-roam-files+ (apply (function append)
				  (mapcar
				   (lambda (directory)
					  (directory-files-recursively directory org-agenda-file-regexp))
				      '("~/org-roam/"))))

  (setq org-refile-targets
	'((nil :maxlevel . 5)
	  (org-agenda-files :maxlevel . 5)
	  (+personal-org-roam-files+ :maxlevel . 5)
	  )
	;; Without this, completers like ivy/helm are only given the first level of
	;; each outline candidates. i.e. all the candidates under the "Tasks" heading
	;; are just "Tasks/". This is unhelpful. We want the full path to each refile
	;; target! e.g. FILE/Tasks/heading/subheading
	org-refile-use-outline-path 'file
	org-outline-path-complete-in-steps nil)
#+end_src

#+RESULTS:

** the todo-keywords cycle
Track state changes.
+ ! :: timestamp 
+ @ :: timestamp with note

#+begin_src emacs-lisp
  (setq org-todo-keywords
	'((sequence "MAYBE(m@)" "TODO(t)" "IN-PROGRESS(i@)" "STUCK(s@/@)" "|" "DONE(d@)" "CANCELLED(c@)")
	  (sequence "REPORT(r)" "BUG(b/@)" "KNOWNCAUSE(k@)" "|" "FIXED(f)")
	  ))
#+end_src

#+RESULTS:
| sequence | MAYBE(m@) | TODO(t)  | IN-PROGRESS(i@) | STUCK(s@/@) |   |          | DONE(d@) | CANCELLED(c@) |
| sequence | REPORT(r) | BUG(b/@) | KNOWNCAUSE(k@)  |             |   | FIXED(f) |          |               |
#+begin_src emacs-lisp
  (setq org-stuck-projects
	;; identify a project with TODO keywords/tags
	;; identify non-stuck state with TODO keywords
	;; identify non-stuck state with tags
	;; regexp match non-stuck projects
	'("-moyu&-MAYBE" ("TODO" "IN-PROGRESS" "BUG" "KNOWNCAUSE") nil ""))
#+end_src

#+RESULTS:
| -moyu&-MAYBE | (TODO IN-PROGRESS BUG KNOWNCAUSE) | nil |   |

** export
#+begin_src emacs-lisp
(setq org-export-with-toc nil)
#+end_src
** babel
*** basic settings

#+begin_src emacs-lisp

  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
#+end_src

#+RESULTS:
: current-window

*** languages

Include languages: 
#+begin_src emacs-lisp

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (shell . t)
   (java . t)
   (C . t)
   (clojure . t)
   (js . t)
   (ditaa . t)
   (dot . t)
   (org . t)
   (latex . t)
   (haskell . t)
   (ditaa . t)
   ))

#+end_src

#+RESULTS:
Set command for python (Ubuntu 20.04 symlinks python to python2.7, so
the default settings calls python2.7).
#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

#+RESULTS:
: python3

#+begin_src python :results output :tangle nil

import sys
print(sys.version)
#+end_src

#+RESULTS:
: 3.8.5 (default, Jul 28 2020, 12:59:40) 
: [GCC 9.3.0]

** latex
#+begin_src emacs-lisp
(use-package auctex
  :defer t)

(use-package cdlatex
  :hook (org-mode . turn-on-org-cdlatex))
#+end_src

*** TODO rewrite clear cache
#+begin_src emacs-lisp
(defun langou/org-latex-delete-cache () (interactive)
       (delete-directory "~/.emacs.d/.local/cache/org-latex" :RECURSIVE t))
#+end_src

** org-roam

[[info:org-roam#Directories and Files][info:org-roam#Directories and Files]]
All org files, *at any level of nesting*, are considered part of the
org-roam. Hence one doesn't have to include all subdirectories
recursively as for =org-directory.=

#+begin_src emacs-lisp
  (use-package org-roam
    :commands org-roam-mode
    :init (add-hook 'after-init-hook 'org-roam-mode)
    :config
    (progn (setq org-roam-directory "~/org-roam")
           (setq org-roam-tag-sources
                 (list
                  'prop
                  'last-directory)))
    :bind (("C-c r f" . org-roam-find-file)
           ("C-c r c" . org-roam-db-build-cache)
           ("C-c r i" . org-roam-insert)
           ("C-c r t" . org-roam-tag-add)
           ))
#+end_src

#+RESULTS:
: org-roam-tag-add

#+begin_src emacs-lisp
(use-package org-roam-server
  :ensure t
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))
#+end_src
#+RESULTS:
: t

#+RESULTS:
| ~/org-roam/20201214204228-ros_tf2.org | ~/org-roam/20201214205049-rviz.org | ~/org-roam/20201214205651-realsense_ros_slam.org | ~/org-roam/20201214211147-t265.org | ~/org-roam/20201214222731-realsenseapi.org | ~/org-roam/20201214223854-ros_messages.org | ~/org-roam/20201214224109-slaminjava.org | ~/org-roam/20201215124701-rospy.org | ~/org-roam/20201215132203-ubuntu20_04python.org | ~/org-roam/20201216124143-org_roam.org | ~/org-roam/20201216125059-hightlight_current_line.org | ~/org-roam/20201216125829-org_roam_titles.org | ~/org-roam/20201216131340-org_roam_tags.org | ~/org-roam/20201216134825-org_refile.org | ~/org-roam/20201216143227-org_tag.org | ~/org-roam/20201216152610-dkf.org | ~/org-roam/20201216211516-landmark_measurements.org | ~/org-roam/20201217210551-roscheatsheet.org | ~/org-roam/20201218204707-online_slam.org | ~/org-roam/20201218204931-slam_classification.org | ~/org-roam/20201218205027-full_slam.org | ~/org-roam/20201218212202-ekf_localization.org | ~/org-roam/20201218215300-linear_change_of_gaussian_random_variable.org | ~/org-roam/20201218222748-closure_properties_of_gaussian.org | ~/org-roam/20201218222758-convolution_of_gaussians.org | ~/org-roam/20201218224913-the_correspondence_problem.org | ~/org-roam/20201218224937-maximum_likelihood_correspondence.org | ~/org-roam/20201219104714-sum_of_gaussian_random_variable.org | ~/org-roam/20201219113346-kalman_filter_measurement_update.org | ~/org-roam/20201219114054-second_order_derivative_or_matrix.org | ~/org-roam/20201219124804-full_bayesian_implementation_of_ekf_under_unkown_data_association.org | ~/org-roam/20201219124946-mht.org | ~/org-roam/20201219165336-ekf_slam.org | ~/org-roam/20201222135306-regexp_sentence_end.org | ~/org-roam/20201223191322-uwa_framework.org | ~/org-roam/20201225012254-pyplot_colors.org | ~/org-roam/20201225023227-particle_filter_in_python.org | ~/org-roam/20201226011741-shell_script_array_size.org | ~/org-roam/20201226011850-shell_script_give_command_output_to_an_array.org | ~/org-roam/20201226013739-shell_script_number_of_command_line_arguments.org | ~/org-roam/20201226134132-emacs_tips.org | ~/org-roam/20201226192118-ssh_passphrase.org | ~/org-roam/20201227183820-catkin_build.org | ~/org-roam/20201227190758-catkin_clean.org | ~/org-roam/fastSLAM.org | ~/org-roam/particleFilter.org | ~/org-roam/pointCloudRegistration.org |

** org-capture
[2020-12-24 四] A weired phenomena that I just found is that the
result of using defvar and using string for filename directly is
different!  If I use defvar after =file+headline=, the filename is
understood as a file in the relative path and something like
=~/vanilla/just-for-fun.org= is created (clearly the evaluation
happens in the org file in =~/vanilla=. However, if a string
="just-for-fun.org"= is given instead, Emacs understands it as a file
in my org-directory.

   #+begin_src emacs-lisp
     (defvar +org-capture-journal-file+ "journal.org")
     (defvar +org-capture-todo-file+ "todo.org")
     (defvar +org-capture-notes-file+ "notes.org")
     (defvar +org-capture-just-for-fun-file+ "just-for-fun.org")

     ;;;; org-journal
     (global-set-key (kbd "C-c j") #'(lambda ()
                                       (interactive)
                                       (find-file
                                        (concat org-directory "/journal.org"))))

     (global-set-key (kbd "C-c c") #'org-capture)
     (global-set-key (kbd "H-c") #'org-capture)

     (setq org-capture-templates
             '(("t" "Personal todo" entry
                (file+headline "todo.org" "Inbox")
                "* TODO [%^{Select the urgency|A|B|C}] %?\n%i\n%a\n" :prepend t)

               ("n" "Personal notes" entry
                (file+headline "notes.org" "Inbox")
                "* %U %?\n%i\n%a" :prepend t)

               ("f" "Maybe it would be fun someday..." entry
                (file+headline "just-for-fun.org" "Inbox")
                "* MAYBE %U %?" :prepend t)

               ;; declare root node j
               ("j" "Journal")

               ("ja" "Journal arbitrary recording" entry
                (file+olp+datetree "journal.org")
                "* %?\n%U\n%i" :tree-type week)

               ("jc" "journal clock into something new" entry
                (file+olp+datetree "journal.org")
                "* %?" :clock-in t :clock-keep t :tree-type week)

               ("jn" "journal edit the task currently clocked in" plain
                (clock) "%?" :unnarrowed t)

               ("r" "read later" checkitem
                (file+headline "read-later.org" "Inbox")
                "[ ] %? ")

               ("b" "bug" entry
                (file+headline "bug.org" "Inbox")
                "* BUG %^{header}\n%U\n#+begin_src\n\n%i\n\n#+end_src\n%?")

               ("v" "vocabularies" entry
                (file+headline "voc.org" "Inbox")
                "* %<%Y-%m-%d %H:%M:%S>\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Basic\n:ANKI_DECK: langou gre\n:END:\n** Front\n%?\n** Back\n\n")))
   #+end_src

   #+RESULTS:
   | t | Personal todo | entry | (file+headline todo.org Inbox) | * TODO [%^{Select the urgency | A | B | C}] %? |
** org-agenda
#+begin_src emacs-lisp
(setq org-agenda-files (apply (function append)
			        (mapcar
			         (lambda (directory)
				        (directory-files-recursively directory org-agenda-file-regexp))
			            '("~/org/"))))
#+end_src

#+RESULTS:
| ~/org/journal/2020-10-25.org | ~/org/journal/2020-10-30.org | ~/org/journal/2020-11-12.org | ~/org/journal/2020-11-13.org | ~/org/journal/2020-11-14.org | ~/org/journal/2020-11-17.org | ~/org/journal/2020-12-20.org | ~/org/bug.org | ~/org/journal.org | ~/org/just-for-fun.org | ~/org/notes.org | ~/org/read-later.org | ~/org/todo.org | ~/org/voc.org |
** habit
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit)
  (global-set-key (kbd "s-a") #'org-agenda)
#+end_src

#+RESULTS:
: org-agenda

** completion 

#+begin_src emacs-lisp

  (add-to-list 'org-modules 'org-tempo)
  (setq org-structure-template-alist
    '(("a" . "export ascii\n")
      ("c" . "center\n")
      ("C" . "comment\n")
      ("e" . "src emacs-lisp\n")
      ("cp" . "src cpp\n")
      ("py" . "src python\n")
      ("sh" . "src shell")
      ("E" . "export")
      ("h" . "export html\n")
      ("l" . "export latex\n")
      ("q" . "quote\n")
      ("s" . "src")
      ("v" . "verse\n")))
#+end_src

#+RESULTS:
#+begin_example
((a . export ascii
) (c . center
) (C . comment
) (e . src emacs-lisp
) (cp . src cpp
) (py . src python
) (sh . src shell) (E . export) (h . export html
) (l . export latex
) (q . quote
) (s . src) (v . verse
))
#+end_example
** pdf
#+begin_src emacs-lisp

(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))

(use-package org-noter)

(use-package org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

#+RESULTS:
: t

** misc
*** TODO shortkey conflict 
shortkey of org-mark-ring-goto conflicts with yasnippet.
* miscellaneous

** set debug on error, load custom

#+begin_src emacs-lisp

  (setq debug-on-error t)
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)

#+end_src

#+RESULTS:
: t

** default browser
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
#+end_src

#+RESULTS:
: browse-url-firefox

** command-log
  #+begin_src emacs-lisp
  (use-package command-log-mode)
  #+end_src
** ligature
#+begin_src emacs-lisp
    (defconst lisp--prettify-symbols-alist
	'(("lambda"  . ?λ)))

    (add-hook 'lisp-mode-hook #'(lambda () (interactive)
				 (prettify-symbols-mode +1)))


  (setq python-prettify-symbols-alist
	(list
	 '("lambda"  . ?λ)
	 '("**2" . ?²)
	 '("sum" . ?∑)
	 '("sigma" . ?σ)
	 '("mu" . ?μ)
	 '("theta" . ?θ)
	 '("_0" . ?₀)
	 '("_1" . ?₁)
	 '("_2" . ?₂)
	 ))
#+end_src

#+RESULTS:
: ((lambda . 955) (**2 . 178) (sum . 8721) (sigma . 963) (mu . 956) (theta . 952))

** bookmarks

#+begin_src emacs-lisp

  (global-set-key (kbd "s-m") #'bookmark-set)

#+end_src

In addition, s-<return> is bound to =helm-filtered-bookmarks= in [[*helm]].

** dictionary

#+begin_src elisp

  (use-package define-word
    :bind
    (("C-c d" . define-word-at-point)
     ("C-c D" . define-word)))
#+end_src

#+RESULTS:
: define-word

** transparency

Interactively toggle transparency in winframe.
#+begin_src emacs-lisp

  (defun transparency (value)
    "sets the transparency of the frame window. 0=transparent/100=opaque"
    (interactive "ntransparency value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

#+RESULTS:
: transparency

** cursor in =-nw= mode

currently disabled as I'm not using evil.
#+begin_src emacs-lisp :tangle nil

  (unless (display-graphic-p)
          (require 'evil-terminal-cursor-changer)
          (evil-terminal-cursor-changer-activate) ; or (etcc-on)
          )
#+end_src

#+RESULTS:

** focused editing

#+begin_src emacs-lisp

  (use-package olivetti
    :config
    (progn
      ;; occupies 7/10 of the window width  
      (setq-default olivetti-body-width 0.7)
      )
    :bind (("C-c f e" . olivetti-mode)))
#+end_src

#+RESULTS:
: olivetti-mode

** expand-region.el

#+begin_src emacs-lisp

  (use-package expand-region
    :config
    (progn
      (global-set-key (kbd "C-=") #'er/expand-region)
      ))
#+end_src

#+RESULTS:
: t

** remove unused UI components

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-file-dialog nil)
  (setq use-dialog-box t)               ; only for mouse events
  ;; (setq inhibit-splash-screen t)
#+end_src

#+RESULTS:
: t

* lsp

#+begin_src emacs-lisp
  (use-package company
    :config
    (setq company-idle-delay 0)
    :bind
    (("TAB" . company-indent-or-complete-common)))
  (add-hook 'after-init-hook 'global-company-mode)
  (use-package lsp-mode)
  (use-package flycheck)
  (use-package lsp-ui
    :demand flycheck
    :config
    (setq lsp-ui-sideline-show-diagnostics t
	  lsp-ui-sideline-show-hover t))
  (use-package lsp-python-ms
    :ensure t
    :init (setq lsp-python-ms-auto-install-server t
		read-process-output-max 1048576)
    :hook (python-mode . (lambda ()
			    (require 'lsp-python-ms)
			    (lsp))))
#+end_src
#+RESULTS:
| lambda | nil | (require 'lsp-python-ms) | (lsp) |

* music

** basic setup
#+begin_src emacs-lisp
  (use-package emms
    :config
    (progn
      (emms-all)
      (emms-default-players)
      (setq emms-source-file-default-directory "~/Music")
      (setq emms-player-mplayer-parameters
	      '("-slave" "-quiet" "-really-quiet" "-novideo"))))

  (global-set-key (kbd "C-c m m") #'emms)
  (global-set-key (kbd "C-c m p") #'emms-add-playlist)
#+end_src

#+RESULTS:
: emms-add-playlist
** TODO improve config
+ block mplayer from poping up

* e-books and documents

** pdf
#+begin_src emacs-lisp
  (use-package pdf-tools
    :config (pdf-tools-install))
#+end_src

#+RESULTS:
: t

** TODO epub, djvu, mobi

* shell and term

** vterm
#+begin_src emacs-lisp
  (use-package vterm
    :bind (("s-v" . vterm)))
#+end_src

#+RESULTS:
: vterm
** eshell

*** keybinding

#+begin_src emacs-lisp

  (global-set-key (kbd "s-e") #'eshell)


#+end_src

#+RESULTS:
: /usr/local/cbc/bin;/usr/local/cbc/bin;/home/jigang/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

[[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell pop up window]]

#+begin_src emacs-lisp :tangle nil
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (global-set-key (kbd "s-e") 'eshell-here)

  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))
#+end_src

#+RESULTS:
: eshell/x

*** PATH

#+begin_src emacs-lisp

  (setenv "PATH"
    (concat
     ;; manually added
     "/usr/local/cbc/bin" ";"
     (getenv "PATH") ; inherited from OS
    )
  )

#+end_src

*** TODO alias
* modeline config

[[https://occasionallycogent.com/custom_emacs_modeline/index.html][A tutorial]]
[[info:emacs#Mode Line][info:emacs#Mode Line]]
[[help:mode-line-format]]
** the default

CS:CH-FR BUF  POS LINE (MAJOR MODE)
+ CS :: coding system.
+ ':' :: eol convention. Unix by default (on my XPS15 9500 running
  Linux). One may also choose Mac or DOS.
+ &optional @ :: for emacsclient.
+ CH :: change(?) 
+ '-' :: becomes '@' if the current buffer is on a remote machine.
+ FR :: only appears on text terminals
+ BUFF :: name of buffer.
+ POS :: position in the buffer.
  
#+begin_src emacs-lisp

  (defun mode-line-format-raw ()
    (interactive)

    (setq mode-line-format
            '("%e" mode-line-front-space mode-line-mule-info mode-line-client
              mode-line-modified mode-line-remote
              mode-line-frame-identification
              mode-line-buffer-identification " " mode-line-position
              (vc-mode vc-mode)
              "  " mode-line-modes mode-line-misc-info mode-line-end-spaces)
  ))
#+end_src

#+begin_src emacs-lisp :tangle nil

  (use-package diminish)
  (diminish 'ivy-mode)
  (diminish 'auto-revert-mode)
  (diminish 'yas-minor-mode)
  (diminish 'org-cdlatex-mode)
  (diminish 'which-key-mode)
  (diminish 'org-roam-mode)
  (diminish 'company-mode)
#+end_src

#+RESULTS:
|   |
#+begin_src emacs-lisp :tangle nil

  (use-package telephone-line
    :config (progn (setq telephone-line-primary-left-separator 'telephone-line-cubed-left
                         telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left
                         telephone-line-primary-right-separator 'telephone-line-cubed-right
                         telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right
                         telephone-line-height 24)
                   (telephone-line-mode +1)))
#+end_src

#+RESULTS:
: t

** doom modeline

#+begin_src emacs-lisp

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :config
    (progn
      (setq doom-modeline-height 23)))

#+end_src

#+RESULTS:
: t

* languages

#+begin_src emacs-lisp
(global-set-key (kbd "H-r") #'compile)
#+end_src

** lisp-general
#+begin_src emacs-lisp
  (use-package lispy)
  (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1)))
  (add-hook 'racket-mode-hook (lambda () (lispy-mode 1)))
#+end_src

#+RESULTS:
| lambda | nil | (lispy-mode 1) |
** racket
#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

#+RESULTS:
** cmake
#+begin_src emacs-lisp
  (use-package cmake-mode)
#+end_src

#+RESULTS:
** C/C++

*** cpputils-cmake

#+begin_src elisp :tangle nil

  (use-package cpputils-cmake)

  (add-hook 'c-mode-common-hook
            (lambda ()
              (if (derived-mode-p 'c-mode 'c++-mode)
                  (cppcm-reload-all)
                )))
  ;; OPTIONAL, somebody reported that they can use this package with Fortran
  (add-hook 'c90-mode-hook (lambda () (cppcm-reload-all)))
  ;; OPTIONAL, avoid typing full path when starting gdb
  (global-set-key (kbd "C-c C-g")
   '(lambda ()(interactive) (gud-gdb (concat "gdb --fullname " (cppcm-get-exe-path-current-buffer)))))
  ;; OPTIONAL, some users need specify extra flags forwarded to compiler
  (setq cppcm-extra-preprocss-flags-from-user '("-I/usr/src/linux/include" "-DNDEBUG"))
#+end_src

#+RESULTS:
| -I/usr/src/linux/include | -DNDEBUG |

* EXWM

** keybinding

Most keys defined in [[*window and buffer]] are configured as prefix-keys
in exwm windows.  s-<num> switches to <num> th workspace, although
workspace is never used with single monitor (of xps15).

C-p, C-n, C-b, C-f, C-a, C-e are set to send keys to exwm-windows
according to Emacs keybindings (similar to what happens in MacOS and
tweaked gnome).

Firefox provides caret-mode for keyboard-driven text-selection
(Shift + Movement to select). Together with =M-w= configured to send =C-c=
to the exwm-windows, a relatively consistent experience of copying is
achieved.

#+begin_src emacs-lisp 
  (use-package exwm
    :config
    (progn
      (setq exwm-workspace-number 3)
      (setq exwm-input-prefix-keys
            '(?\C-x
              ?\s-o	      ;; switch-to-buffer
              ?\s-i ;; ibuffer
              ?\s-j ;; window switch
              ?\s-c ;; kill window
              ?\s-C ;; kill buffer and window(if not single)
              ?\s-k ;; window switch
              ?\s-v ;; vterm
              ?\s-s ;; single-window-toggle
              ?\s-e ;; pop-up eshell
              ?\C-u ;; general command
              ?\C-h ;; help
              ?\M-x
              ?\M-&
              ?\M-:
              ?\H-c ;; org-capture
              ?\H-s ;; kill other windows
              ?\C-\ ))
      (setq exwm-input-global-keys
            `(([?\s-r] . exwm-reset)
              ([?\s-w] . exwm-workspace-switch)
              ([?\s-\;] . (lambda (command)
                            (interactive (list (read-shell-command "$ ")))
                            (start-process-shell-command command nil command)))
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-%d" i)) .
                            (lambda ()
                              (interactive)
                              (exwm-workspace-switch-create ,i))))
                        (number-sequence 0 9))))
      (exwm-input-set-simulation-keys
       '(([?\C-b] . left)
         ([?\C-f] . right)
         ([?\C-p] . up)
         ([?\C-n] . down)
         ([?\C-a] . home)
         ([?\C-e] . end)
         ([?\M-w] . [?\C-c])
         ))
      (setq exwm-workspace-warp-cursor t
            mouse-autoselect-window t
            focus-follows-mouse t)
      (exwm-enable)
      ))
#+end_src

#+RESULTS:
: t

Ocassionly, key-sequences intercepted by Emacs can be send after C-q.
s-SPC runs #'counsel-linux-app and s-<tab> toggles tab selection.

#+begin_src emacs-lisp

  ;; After C-q, send key to the window 
  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
  (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)
  (exwm-input-set-key (kbd "s-<tab>") 'prot-tab-select-tab-dwim)
#+end_src

#+RESULTS:

** ui tweaks

*** systemtray, time&battery display  

#+begin_src emacs-lisp

  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
  (display-time-mode)
  (display-battery-mode)
#+end_src

#+RESULTS:
| exwm-systemtray--exit |
|                       |

** window configuring

#+begin_src elisp

  (defun efs/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun efs/exwm-init-hook ()
    ;; Make workspace 1 be the one where we land at startup
    (exwm-workspace-switch-create 0)

    ;; Open eshell by default
    ;;(eshell)

    ;; NOTE: The next two are disabled because we now use Polybar!

    ;; Show battery status in the mode line
    ;;(display-battery-mode 1)

    ;; Show the time and date in modeline
    ;;(setq display-time-day-and-date t)
    ;;(display-time-mode 1)
    ;; Also take a look at display-time-format and format-time-string

    ;; Start the Polybar panel
    ;; (efs/start-panel)

    ;; Launch apps that will run in the background
    (efs/run-in-background "dunst")
    (efs/run-in-background "nm-applet")
    (efs/run-in-background "pasystray")
    (efs/run-in-background "blueman-applet")
    (efs/run-in-background "electron-ssr"))

  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))
      ("electron-ssr" (progn
                        (exwm-workspace-rename-buffer "electron-ssr")
                        (exwm-workspace-move-window 2)))))

  ;; This function isn't currently used, only serves as an example how to
  ;; position a window
  (defun efs/position-window ()
    (let* ((pos (frame-position))
           (pos-x (car pos))
            (pos-y (cdr pos)))
      (exwm-floating-move (- pos-x) (- pos-y))))

  (defun efs/configure-window-by-class ()
    (interactive)
    (pcase exwm-class-name
      ("electron-ssr" (exwm-floating-toggle-floating))))

  ;; When EXWM starts up, do some extra confifuration
  (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

  ;; When window "class" updates, use it to set the buffer name
  (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

  ;; When window title updates, use it to set the buffer name
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  ;; Configure windows as they're created
  (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)


#+end_src

#+RESULTS:
| efs/configure-window-by-class |

** workspaces and monitors
Make sure xrandr update refresh EXWM frames.
Assign workspaces to monitors.
#+begin_src emacs-lisp
  (require 'exwm-randr)
  (setq exwm-randr-workspace-monitor-plist '(1 "DP-1-2" 1 "DP-2" 1 "DP-1-1" 1 "DP-1"))
  (exwm-randr-enable)
#+end_src

#+RESULTS:
| exwm-randr--exit | exwm-systemtray--exit |

#+begin_src emacs-lisp
  (defun efs/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun efs/update-displays ()
    (efs/run-in-background "autorandr --change --force")
    (message "Display config: %s"
	     (string-trim (shell-command-to-string "autorandr --current"))))

  (add-hook 'exwm-randr-screen-change-hook #'efs/update-displays)
  (efs/update-displays)

#+end_src

** wallpaper
#+begin_src elisp

  (unless (executable-find "feh")
    (display-warning 'wallpaper "External command `feh' not found!"))

  ;; This is an example `use-package' configuration
  ;; It is not tangled into wallpaper.el
  (use-package wallpaper
    :ensure t
    :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
           (after-init . wallpaper-cycle-mode))
    :custom ((wallpaper-cycle-single t)
             (wallpaper-scaling 'scale)
             (wallpaper-cycle-interval 45)
             (wallpaper-cycle-directory "~/Pictures/Wallpapers")))
#+end_src

#+RESULTS:
| wallpaper-cycle-mode | global-company-mode | org-roam-mode | x-wm-set-size-hint | tramp-register-archive-file-name-handler | magit-maybe-define-global-key-bindings | table--make-cell-map |

* anki

anki-editor provides anki-integration with org-mode.
see [[*org-capture]] for capture-templates creating anki entries.

#+begin_src emacs-lisp

  (use-package anki-editor)
#+end_src

#+RESULTS:

* meta

Automatically tangle /this file/ on save.

#+begin_src elisp

  (defun efs/org-babel-tangle-config ()
    (when (string-equal (file-name-directory (buffer-file-name))
                        (expand-file-name user-emacs-directory))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))

#+end_src

#+RESULTS:
| (lambda nil (add-hook 'after-save-hook #'efs/org-babel-tangle-config)) | org-tempo-setup | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | org-pdftools-setup-link | turn-on-org-cdlatex | org-indent-mode | (lambda nil (org-bullets-mode 1)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes |
