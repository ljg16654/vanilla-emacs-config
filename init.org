#+TITLE: init
#+PROPERTY: header-args :tangle init.el :results silent
#+startup: showeverything

Some of the awesome configurations used as reference:

+ James Cash :: [[https://github.com/jamesnvc/dotfiles]]
+ Protesilaos Stavrou :: https://protesilaos.com/dotemacs/
+ Doom Emacs :: [[https://github.com/hlissner/doom-emacs]]
+ Emacs From Scratch Series :: [[https://github.com/daviwil/emacs-from-scratch]]

* personal info

#+begin_src emacs-lisp
(setq user-full-name "Jigang Li"
      user-mail-address "ljg16654@sjtu.edu.cn")
#+end_src

* server

#+begin_src emacs-lisp
(server-start)
#+end_src

* straight.el

#+begin_src emacs-lisp
;; each use-package form also invoke straight.el to install the package
(setq straight-use-package-by-default t)
#+end_src

#+begin_src emacs-lisp

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

then, install =use-package= with straight.el:

#+begin_src emacs-lisp

(straight-use-package 'use-package)
#+end_src

On usage of defer:
#+begin_quote

In almost all cases you don't need to manually specify :defer t. This
is implied whenever :bind or :mode or :interpreter is used. Typically,
you only need to specify :defer if you know for a fact that some other
package will do something to cause your package to load at the
appropriate time, and thus you would like to defer loading even though
use-package isn't creating any autoloads for you.
#+end_quote

* elisp libs

Libraries useful for writing elisp but may not be used interactively.

#+begin_src emacs-lisp
(use-package s)
(use-package dash)
(use-package f)
(use-package flx)
#+end_src

* keybinding and grouping commands

[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][mastering key bindings emacs]]
/Function/ and /navigation/ keys, i.e. keys including F-keys, arrow keys
and home row keys, should be wrapped with =<= and =>=.

** general.el

For examples, see [[file:../org-roam/20210113022951-general_el_define_keybinding.org][general.el define keybinding]].

#+begin_src emacs-lisp

(use-package general)
#+end_src

** key-chord

#+begin_src emacs-lisp

(use-package key-chord
  :init
  (setq key-chord-two-keys-delay 0.05)
  (setq key-chord-one-key-delay 0.2)
  :config
  (key-chord-mode t)
  (key-chord-define-global ",." "<>\C-b")
  (key-chord-define-global "dk" "()\C-b")
  (key-chord-define-global "jk" "[]\C-b")
  (key-chord-define-global "JK" "{}\C-b")
  )
#+end_src

** evil

#+begin_src emacs-lisp
;; variables that must be set before Evil is loaded:
(setq evil-respect-visual-line-mode t)
(setq evil-want-keybinding nil)

(use-package evil
  :config
  (progn
    (setq
     evil-want-C-d-scroll nil
     evil-want-C-u-delete nil
     evil-regexp-search t
     evil-auto-indent t
     evil-cross-lines t
     evil-insert-state-cursor 'hbar
     )
    (evil-mode +1)
    ))

(setq evil-want-Y-yank-to-eol t)
(setq evil-undo-system #'undo-redo)

;; major modes in which I prefer Emacs keybinding
(evil-set-initial-state 'Info-mode 'emacs)
(evil-set-initial-state 'elfeed-show-mode 'emacs)
(evil-set-initial-state 'elfeed-search-mode 'emacs)
(evil-set-initial-state 'nov-mode 'emacs)

(use-package evil-snipe
  :config
  (progn
    (setq evil-snipe-spillover-scope 'whole-buffer)
    (evil-snipe-mode +1)
    (evil-snipe-override-mode +1)))

;; '%' to jump
(use-package evil-matchit)
(global-evil-matchit-mode)

(use-package evil-exchange)
(evil-exchange-install)

;; customize evil-surround-pairs-alist
;; notice that different effects are expected from
;; cs[( and cs])
(use-package evil-surround
  :config
  (progn (global-evil-surround-mode 1)))

(use-package evil-embrace
  :after evil-surround
  :hook (LaTeX-mode . embrace-LaTeX-mode-hook)
  :hook (org-mode . embrace-org-mode-hook)
  :hook (emacs-lisp-mode . embrace-emacs-lisp-mode-hook)
  )


(use-package evil-args)
;; bind evil-args text objects
(define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
(define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

;; bind evil-forward/backward-args
(define-key evil-normal-state-map "L" 'evil-forward-arg)
(define-key evil-normal-state-map "H" 'evil-backward-arg)
(define-key evil-motion-state-map "L" 'evil-forward-arg)
(define-key evil-motion-state-map "H" 'evil-backward-arg)

(use-package evil-nerd-commenter
  :config (progn (evilnc-default-hotkeys)))

(global-set-key (kbd "H-x") #'helm-M-x)
#+end_src

#+begin_src emacs-lisp

(evil-define-key 'normal 'prog-mode-map (kbd "SPC s") #'save-buffer)
(evil-define-key 'normal 'global (kbd "J") #'tab-bar-switch-to-next-tab)
(evil-define-key 'normal 'global (kbd "K") #'tab-bar-switch-to-prev-tab)
(evil-define-key 'normal 'global (kbd "SPC SPC") #'helm-M-x)
(evil-define-key '(insert normal) 'global (kbd "C-e") #'end-of-line)
#+end_src

#+begin_src emacs-lisp
(use-package evil-collection)
(evil-collection-init)
#+end_src

toggling evil:
http://www.makble.com/how-to-toggle-evil-mode-in-emacs

#+begin_src emacs-lisp :tangle nil
(defun toggle-evilmode ()
  (interactive)
  (if (bound-and-true-p evil-local-mode)
    (progn
      ; go emacs
      (evil-local-mode (or -1 1))
      (undo-tree-mode (or -1 1))
      (set-variable 'cursor-type 'bar)
    )
    (progn
      ; go evil
      (evil-local-mode (or 1 1))
      (set-variable 'cursor-type 'box)
    )
  )
)
 
(global-set-key (kbd "M-u") 'toggle-evilmode)
#+end_src


** hydra

[[https://github.com/abo-abo/hydra/wiki][hydra wiki]]

#+begin_src emacs-lisp

(use-package hydra)
(global-set-key (kbd "C-c h") #'hydra-pause-resume)
#+end_src

A minimalistic example:

#+begin_src emacs-lisp

(defhydra landmark (global-map "C-c f")
  "landmarks"
  ("p" #'(lambda () (interactive)
           (find-file (concat user-emacs-directory "init.org")))
   "config")
  ("d" #'(lambda () (interactive)
           (dired "~/Downloads"))
   "downloads")
  ("c" #'(lambda () (interactive)
           (dired "~/Documents"))
   "documents")
  ("r" #'(lambda () (interactive)
           (dired "~/ROS"))
   "ros")
  ("x" #'(lambda () (interactive)
           (dired "~/code"))
   "code")
  ("o" #'(lambda () (interactive)
           (dired org-directory))
   "org")
  ("l" #'(lambda () (interactive)
           (find-file "~/org/reading-list.org")
           "reading list"))
  ("y" #'(lambda () (interactive)
           (dired (concat user-emacs-directory "snippet/"))
           "snippets")))
#+end_src

* completion

'Emacs isn't Emacs without completion.'

** helm

*** setup

#+begin_src emacs-lisp

(use-package helm)

(setq helm-completion-style 'helm)
#+end_src

*** geometry

#+begin_src emacs-lisp

(helm-autoresize-mode)
(setq helm-autoresize-max-height 40)

#+end_src

posframe:

#+begin_src emacs-lisp

(use-package helm-posframe
  :config
  (progn
    (setq helm-posframe-parameters
          '((left-fringe . 10)
            (right-fringe . 10)))
    ;; (helm-posframe-enable)
    ))

#+end_src


*** speed up candidate selection

#+begin_src emacs-lisp

(use-package ace-jump-helm-line)
(eval-after-load "helm"
  '(define-key helm-map (kbd "C-'") 'ace-jump-helm-line))

#+end_src

** minibuffer completion

By default, one needs to press 'M-v' to jump to the *completion*
buffer. With =fido= or =icomplete=, however, rotation inside the candidate
list can be done right inside the minibuffer with 'C-,' and 'C-.'.

#+begin_src emacs-lisp
(icomplete-mode t)
(global-set-key (kbd "M-i") #'ido-imenu-anywhere)
#+end_src

#+begin_src emacs-lisp
(use-package orderless)
(require 'orderless)
#+end_src

Just like company, the Emacs completion supports multiple completions,
which are called iteratively (see [[help:completion-cycle-threshold]] for
fine-tuning the interation) during the process.
These completions are stored in the variable =completion-styles=.

#+begin_src emacs-lisp
(setq completion-styles
      '(partial-completion
	flex
	initials
	substring
	orderless))

;; for file name completion, ignore case
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
#+end_src

Different completion styles can be set depending on the context: set
[[help:completion-category-overrides]] which overrides completion-category-defaults.

#+begin_src emacs-lisp

;; set files to ignore in completion
;; completion-ignored-*

#+end_src

Embark provides meaningful actions on objects.
For minibuffer, try out 'S', 'L', 'E'!

#+begin_src emacs-lisp

(use-package embark
  :config
  (global-set-key (kbd "s-,") #'embark-act)
  (global-set-key (kbd "H-b") #'embark-bindings))
#+end_src

** yasnippet

[[http://joaotavora.github.io/yasnippet/snippet-development.html][how to write?]]
[[http://joaotavora.github.io/yasnippet/snippet-expansion.html][expanding snippets]]

#+begin_src emacs-lisp
(use-package yasnippet
  :config
  (progn
    (setq yas-snippet-dirs
          (list (concat user-emacs-directory "snippet/")))
    (yas-global-mode)))
#+end_src

Yasnippet's own major-mode, =snippet-mode=, provides
=yas-tryout-snippet= (bound to C-c C-t) by default for users to
experiment with the snippet's effect immediately.
Also, C-c C-c does things similar to what it does inside =org-mode=.

What makes this package particularly 'Emacsy', from my perspective, is
its ability to leverage the power of elisp:
- =# consition= keyword :: conidition for expansion.
- # =expand-env= keyword :: temporarily replace some variables during
  snippet expansion.
  
Integration with helm:

#+begin_src emacs-lisp

(use-package helm-c-yasnippet
  :after (helm yasnippet)
  :config
  (progn
    (setq helm-yas-space-match-any-greedy t)
    (global-set-key (kbd "C-c y") 'helm-yas-complete)
    ))
#+end_src

** which key
#+begin_src emacs-lisp
(use-package which-key
  ;; :init (which-key-mode)
  :config
  (setq which-key-idle-delay 0.3))
#+end_src

enhance ivy with ivy-rich: 
#+begin_src emacs-lisp :tangle nil
  (use-package ivy-rich
    :config (ivy-rich-mode +1))
#+end_src

** company delay

#+begin_src emacs-lisp

(use-package company
  :config
  (setq company-idle-delay 0)
  )

(add-hook 'after-init-hook 'global-company-mode)

#+end_src

** TAB behavior

https://stackoverflow.com/questions/7022898/emacs-autocompletion-in-emacs-lisp-mode

#+begin_quote

With this setup, TAB - which is usually bound to
indent-for-tab-command - first tries to adjust the indentation
according to the mode's settings, but if the indentation is already
correct, completion is triggered.
#+end_quote

#+begin_src emacs-lisp

(setq tab-always-indent 'complete)
(add-to-list 'completion-styles 'initials t)
#+end_src

* elisp


#+begin_src emacs-lisp
(add-hook 'inferior-emacs-lisp-mode #'(lambda () (autopair-mode t)))
#+end_src

#+begin_src emacs-lisp

(use-package dash)
(use-package f)
#+end_src

* theme, font

[[https://stackoverflow.com/questions/21033270/resizing-echoarea-of-emacsclient][related issue on wired space at bottom]]

#+begin_src emacs-lisp

(set-face-attribute 'default nil :family "Iosevka" :height 135)
(setq line-spacing 0.2)
#+end_src

[[https://protesilaos.com/modus-themes/][modus-theme manual]]

#+begin_src emacs-lisp

(use-package anti-zenburn-theme
  :defer t)

(use-package solarized-theme
  :defer t
  :config
  (progn
    (setq solarized-use-variable-pitch nil)))

(use-package spacemacs-theme
  :defer t)

(use-package apropospriate-theme)

(use-package weyland-yutani-theme)

(use-package doom-themes)

(load-theme 'modus-vivendi t)
#+end_src

* linum

#+begin_src emacs-lisp

(setq linum-format " %d  ")
(add-hook 'python-mode-hook #'linum-mode)
#+end_src

* search/replace

Sometimes, when =lsp= doesn't work for some reasons (for example,
dependencies are not met on the machine and thus =cmake= cannot be
performed), it proves necessary to find definitions and references
through manual search.

Currently I'm experimenting with all kinds of choices in order to find

- best approach to finding symbol under cursor in project.
- difference between =project.el= (shipped with Emacs) and =projectile=.

** rg

In default bindings of =rg=, =C-c s= spawns a transient menu
similar to that of =magit=.
=s-f= is also bound to =rg-menu=.

Severals notes on the manual pages:
- =ripgrep= has it own configuration which is not encourage by =rg= as it
may easily bring about malfunction due to carelessness.
- The variable =rg-ignore-case= can be customized for case sensitivity.
- r :: =rg=. Interprets _query_ string as regexp.
- t :: =rg-literal=. Interprets _query_ string literally.
- p :: =rg-project=.
- d :: =rg-dwim=. Search in project by default while search in
  file/directory can be called with universal arguments.

The package also features isearch integration. While I'm considering
about migration from ivy to swiper, the integration is appended to
read later at the moment.

#+begin_src emacs-lisp

(use-package rg
  :config
  (progn
    (rg-enable-default-bindings))
  :bind
  ("s-f" . rg-menu))

;; seems to be dependency for projectile-ripgrep
(use-package ripgrep) 
#+end_src

*** helm integration

#+begin_src emacs-lisp

(use-package helm-rg
  :after (helm rg))
#+end_src

** ag

#+begin_src emacs-lisp

(use-package ag)
#+end_src

** Iedit

Available /inside a (possibly narrowed) buffer/. For cross-buffer multicursor editing, see [[* isearch, swiper, swoop]].

[[https://github.com/victorhge/iedit][Iedit repo]]
[[https://www.emacswiki.org/emacs/Iedit][EmacsWiki::Iedit]]

- start with C-;
- expand with M-{ or M-} (similar to =expand-region=)
- hide non-matching lines with C-'
- terminate with C-;

#+begin_src emacs-lisp

(global-set-key (kbd "C-;") #'iedit-mode)

#+end_src

Used in combination with
- =narrow-to-defun= (C-x n d)
- =expand-region= (C-=)

** isearch, swiper, swoop

Despite being powerful enough, =isearch-forward= causes least distortion
to window layout. For such reason, the default keymap bound to C-s is
preserved.  In fact, this choice doesn't imply a farewell with helm in
terms of searching. With M-i, =helm-swoop= on the buffer can be called
during isearch (the keybinding makes some sense as I've bound M-i to
=imenu= normally, and one can think of swoop as an interface for the
outline of isearch result). By issuing M-i one more, the search will
be performed throughout all present buffers with =helm-multi-swoop-all=.

#+begin_src emacs-lisp

(use-package helm-swoop)
(global-set-key (kbd "C-s") #'helm-swoop)
(global-set-key (kbd "C-_") #'helm-multi-swoop-all)
;; enable whitespace to match arbitrary string that doesn't contain a newline
;; non-greedily
;; such behavior is, however, limited to non-regexp search
(setq search-whitespace-regexp ".*?")
#+end_src

** regexp search and replace
https://protesilaos.com/dotemacs/#h:b67687ee-25a3-4bf4-a924-180ccb63c629

C-M-s or C-M-r prompts for regexp to search against. Alternatively,
use M-r for =isearch-toggle-regexp= during isearch.y

* windows and buffers

** window rules and management

*** monocle-window

From prot's dotEmacs. Defines a monocole layout similar to Tiling
window managers.

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defvar prot/window-configuration nil
    "Current window configuration.
Intended for use by `prot/window-monocle'.")

  (define-minor-mode prot/window-single-toggle
    "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
    :lighter " [M]"
    :global nil
    (if (one-window-p)
        (when prot/window-configuration
          (set-window-configuration prot/window-configuration))
      (setq prot/window-configuration (current-window-configuration))
      (delete-other-windows)))
  :bind ("C-c s" . prot/window-single-toggle))
#+end_src

*** window placement

#+begin_src emacs-lisp

(use-package popper
  :init
  (setq popper-display-control nil)
  (setq popper-reference-buffers
	(list "\\*Python\\*"
	      "\\*eshell\\*"
              "\\*ielm\\*"))
  :config
  (defhydra 'popper-stuff
    (global-map "C-c t")
    ("t" #'popper-toggle-latest)
    ("o" #'popper-cycle)
    ("p" #'popper-toggle-type))

  (popper-mode +1))

(defun clear-popper-popup-alive ()
  "Clear popup buffers that are currently maintained by
	      popper.el. Useful when related rules are changed."
  (interactive)
  (progn
    (setq popper-open-popup-alist nil)
    (setq popper-buried-popup-alist nil)
    (message "Popper active alist cleared."))
  )

#+end_src

https://depp.brause.cc/shackle/

#+begin_src emacs-lisp :tangle nil
(use-package shackle)
#+end_src

[[https://protesilaos.com/dotemacs/#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][prot window rules]]
[[info:emacs#Window Choice][info:emacs#Window Choice]]

#+begin_src emacs-lisp

(setq display-buffer-alist
      '(
        ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
         (display-buffer-in-side-window)
         (window-height . 0.16)
         (side . top)
         (slot . 0)
         (window-parameters . ((no-other-window . t))))
        ("\\*Messages.*"
         (display-buffer-in-side-window)
         (window-height . 0.16)
         (side . top)
         (slot . 1)
         (window-parameters . ((no-other-window . t))))
        ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
         (display-buffer-in-side-window)
         (window-height . 0.16)
         (side . top)
         (slot . 2)
         (window-parameters . ((no-other-window . t))))
	;; bottom side window
        ("\\*Python\\*"
         (display-buffer-reuse-mode-window display-buffer-at-bottom)
         (window-height . 0.4)
         (side . bottom)
         (slot . 1)
	 (window-parameters ((mode-line-format . none))
			    ))
        ("\\*ielm\\*"
         (display-buffer-reuse-mode-window display-buffer-at-bottom)
         (window-height . 0.4)
         (side . bottom)
         (slot . 2))
	("\\*Async Shell Command\\*"
	 (display-buffer-no-window))
        ;; left side window
        ("\\*Help.*"
         (display-buffer-reuse-mode-window display-buffer-at-bottom)
         (window-height . 0.35)       ; See the :hook
         (side . left)
         (slot . 0))
	("\\*pytest.*"
	 (display-buffer-in-side-window)
	 (window-width . 0.35)       ; See the :hook
	 (side . left)
	 (slot . 0)
         (window-parameters . ((no-other-window . t))))

        ;; right side window
        ("\\*Faces\\*"
         (display-buffer-in-side-window)
         (window-width . 0.25)
         (side . right)
         (slot . 0)
         (window-parameters
          . ((mode-line-format
              . (" "
                 mode-line-buffer-identification)))))
        ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
         (display-buffer-reuse-mode-window display-buffer-at-bottom)
         (window-height . 0.4)
         ;; (mode . '(eshell-mode shell-mode))
         )))

(setq window-combination-resize t)
(setq even-window-sizes 'height-only)
(setq window-sides-vertical nil)
(setq switch-to-buffer-in-dedicated-window 'pop)
(global-set-key (kbd "s-q") #'window-toggle-side-windows)
(global-set-key (kbd "C-c 2") #'window-toggle-side-windows)
(add-hook 'help-mode-hook #'visual-line-mode)
(add-hook 'custom-mode-hook #'visual-line-mode)
#+end_src

**** man page window behavior

#+begin_src emacs-lisp
(setq Man-notify-method 'pushy)
#+end_src


*** window-layout history

Waiting for confirmation before tangling.

#+begin_src emacs-lisp :tangle nil

(use-package winner
  :hook (after-init-hook . winner-mode)
  :bind (("s-S-<left>" . winner-redo)
         ("s-S-<right>" . winner-undo)))

#+end_src

** eyebrowse

#+begin_src emacs-lisp

(use-package eyebrowse)
(setq eyebrowse-new-workspace t)
(global-set-key (kbd "η") #'eyebrowse-prev-window-config)
(global-set-key (kbd "λ") #'eyebrowse-next-window-config)
(global-set-key (kbd "ν") #'eyebrowse-create-named-window-config)
(global-set-key (kbd "ρ") #'eyebrowse-switch-to-window-config)
#+end_src

** buffer switch keys

#+begin_src emacs-lisp

;; between buffers

(global-set-key (kbd "s-o") #'switch-to-buffer)
(global-set-key (kbd "C-x C-b") #'ibuffer)
(evil-define-key 'normal 'global (kbd "SPC b i") #'ibuffer)
(global-set-key (kbd "C-M-,") #'previous-buffer)
(global-set-key (kbd "C-M-.") #'next-buffer)
(global-set-key (kbd "C-x <return> r")
		;; originally bound to
		;; revert-buffer-with-coding-system
		#'revert-buffer)
(evil-define-key 'normal 'global (kbd "SPC b r") #'revert-buffer)

;; inside a tab

(setq aw-keys
      (list ?a ?s ?d ?f ?j ?k ?l))

(global-set-key (kbd "χ") #'other-window)
(global-set-key (kbd "H-s") #'delete-other-windows)

#+end_src

** tab-bar

#+begin_src emacs-lisp

(use-package tab-bar
  :init
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice "*scratch*")
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
  :config
  (tab-bar-mode -1)
  (tab-bar-history-mode -1))

(defun prot-tab--tab-bar-tabs ()
  "Return a list of `tab-bar' tabs, minus the current one."
  (mapcar (lambda (tab)
            (alist-get 'name tab))
          (tab-bar--tabs-recent)))

(defun prot-tab-select-tab-dwim ()
  "Do-What-I-Mean function for getting to a `tab-bar' tab.
  If no other tab exists, create one and switch to it.  If there is
  one other tab (so two in total) switch to it without further
  questions.  Else use completion to select the tab to switch to."
  (interactive)
  (let ((tabs (prot-tab--tab-bar-tabs)))
    (cond ((eq tabs nil)
           (tab-new))
          ((eq (length tabs) 1)
           (tab-next))
          (t
           (tab-bar-switch-to-tab
            (completing-read "Select tab: " tabs nil t))))))

(defun prot-tab-tab-bar-toggle ()
  "Toggle `tab-bar' presentation."
  (interactive)
  (if (bound-and-true-p tab-bar-mode)
      (progn
        (setq tab-bar-show nil)
        (tab-bar-mode -1))
    (setq tab-bar-show t)
    (tab-bar-mode 1)))

(defconst tab-leader "C-x t")

(general-create-definer tab-leader-def
  :prefix tab-leader)

;; global hyper leader def
(tab-leader-def
  "n" 'tab-bar-new-tab
  "r" 'tab-bar-rename-tab
  "k" 'tab-bar-close-tab
  "t" 'prot-tab-tab-bar-toggle
  "<tab>" 'prot-tab-select-tab-dwim)

(global-set-key (kbd "C-x t t") #'prot-tab-select-tab-dwim)
(global-set-key (kbd "ψ") #'prot-tab-select-tab-dwim)
#+end_src

integration with projectile:
https://www.reddit.com/r/emacs/comments/bhj7tu/tabbar_with_projectile_grouping/

** kill buffer
#+begin_src emacs-lisp

(defun prot-simple-kill-buffer-current (&optional arg)
  "Kill current buffer or abort recursion when in minibuffer.
With optional prefix ARG (\\[universal-argument]) delete the
buffer's window as well."
  (interactive "P")
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer)))
  (when (and arg
             (not (one-window-p)))
    (delete-window)))

(global-set-key (kbd "s-c") #'prot-simple-kill-buffer-current)
(global-set-key (kbd "s-C") #'(lambda ()
                                (interactive)
                                (prot-simple-kill-buffer-current 1)))

#+end_src

** buffer naming

#+begin_src emacs-lisp

(global-set-key (kbd "C-c b r") #'rename-buffer)
#+end_src

** window resize

#+begin_src emacs-lisp

(use-package golden-ratio
  :config
  (progn
    (setq golden-ratio-exclude-modes
          (list
           "eshell-mode"
           "vterm-mode"
           "helm-mode"
           "dired-mode"))
    ))

#+end_src

* movement

In buffer or across buffers.
** avy
#+begin_src emacs-lisp

(use-package avy)

(global-set-key (kbd "θ") #'ace-window)

#+end_src

* project

** version control

#+begin_src emacs-lisp

(use-package magit
  :bind (("C-c g" . magit))
  )

(evil-define-key 'normal 'global (kbd "SPC g") #'magit)

(use-package git-gutter)
#+end_src

** projectile

#+begin_src emacs-lisp

(use-package projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

integration with helm:

see https://github.com/bbatsov/persp-projectile/issues/23 for the
=:after= keyword here.

#+begin_src emacs-lisp


(use-package helm-projectile
  ;; :after persp-projectile
  :after helm-rg
  :config
  (progn
    (helm-projectile-on)
    ))

#+end_src

integration with ibuffer:

#+begin_src emacs-lisp

(use-package ibuffer-projectile
  :after projectile
  :config
  (progn
    (add-hook 'ibuffer-hook
	      (lambda ()
		(ibuffer-projectile-set-filter-groups)
		(unless (eq ibuffer-sorting-mode 'alphabetic)
		  (ibuffer-do-sort-by-alphabetic))))))
#+end_src

integration with org:
[[https://github.com/IvanMalison/org-projectile/tree/96a57a43555e24e5e0d81e79f0fbb47001c41bachttps://github.com/IvanMalison/org-projectile/tree/96a57a43555e24e5e0d81e79f0fbb47001c41bac][repo]]

#+begin_src emacs-lisp

(use-package org-projectile
  :after (org projectile)
  :config
  (progn
    (setq org-projectile-projects-file
          (concat org-directory "/project.org"))
    (global-set-key (kbd "C-c n p")
                    #'org-projectile-project-todo-completing-read)
    ))
#+end_src

** perspective.el

The [[https://github.com/nex3/perspective-el][repo]] includes the desired workflow bound with such package. What
interests me particularly is the term "Yak shaving", which describes
'any seemingly pointless activity which is actually necessary to solve
a problem which solves a problem which, several levels of recursion
later, solves the real problem you're working on.' Such an everyday
senario has so far been neglected in my choice of buffer/window
grouping tool due to naïvety.

The package is currently disabled as =persp-projectile= doesn't seem to
function properly according to my expectation (a new 'perspective' is
not created after I issue projectile switch). Also, the git repo isn't
exhausive as I would normally expect from an Emacs package. Therefore,
I decide to continue with =tar-bar= and =projectile=.

#+begin_src emacs-lisp :tangle nil

(use-package perspective
  :config
  (progn
    (persp-mode)
    (setq persp-sort 'acess)))

#+end_src

integration with projectile:

#+begin_src emacs-lisp :tangle nil

(use-package persp-projectile)

#+end_src

** dumb-jump

#+begin_src emacs-lisp

(use-package dumb-jump
  :config
  (progn
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (setq dumb-jump-debug t)
    (setq dumb-jump-aggressive t)
    (setq dumb-jump-selector 'helm)
    ))

#+end_src

* dired

*** basic

#+begin_src emacs-lisp

(use-package dired
  :straight nil
  :ensure nil
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t))

#+end_src

#+begin_src emacs-lisp

(add-hook 'dired-mode
          #'(lambda ()
              (progn
                (dired-hide-details-mode +1)
                (dired-omit-mode +1)
                )))
#+end_src

*** TODO improve
- hide-detail not working
- pipe to shell, group operation

#+begin_src emacs-lisp

(use-package dired-subtree
  :after dired
  :config
  (progn
    (setq dired-subtree-use-backgrounds nil)
    )
  :bind
  (:map dired-mode-map
        ("<tab>" . dired-subtree-toggle)
        ("C-<tab>" . dired-subtree-cycle)
        ))
#+end_src


#+begin_src emacs-lisp

  (use-package peep-dired
    :bind
    (:map dired-mode-map
     ("`" . peep-dired)
     ))
#+end_src


#+begin_src emacs-lisp

(use-package dired-filter
  :bind
  (:map dired-mode-map
	("/" . dired-filter-mark-map)
	)
  )
#+end_src

*** keybinding
The default '^' for =dired-up-directory= feels a bit clumsy.  For such
reason, ';' is binded to the same function in dired-mode using
general.el.

#+begin_src emacs-lisp
(require 'general)

(general-define-key
 :keymaps 'dired-mode-map
 ";" #'dired-up-directory
 )

#+end_src

* org

#+begin_src emacs-lisp

(use-package org
  :config
  (progn
    (define-key org-mode-map (kbd "C-,") nil)
    (setq org-ellipsis " ▾"
          org-hide-emphasis-markers t
          org-imenu-depth 7
          )
    (local-unset-key (kbd "C-'"))
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))))

#+end_src

** links

#+begin_src emacs-lisp

(global-set-key (kbd "C-c n l") #'org-store-link)
#+end_src

** evil meta-left/right

#+begin_src emacs-lisp

(general-define-key
 :keymaps 'org-mode-map
 "M-h" #'org-metaleft
 "M-l" #'org-metaright
 "C-c e" #'org-mark-element)
#+end_src

** auto-fill

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook #'auto-fill-mode)
#+end_src

** appearance

#+begin_src emacs-lisp

(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(add-hook 'org-mode-hook #'org-indent-mode)
#+end_src

** refile
#+begin_src emacs-lisp
(setq +personal-org-roam-files+ (apply (function append)
                                       (mapcar
					(lambda (directory)
                                          (directory-files-recursively directory org-agenda-file-regexp))
					'("~/org-roam/"))))

(setq org-refile-targets
      `((nil :maxlevel . 2)
        (org-agenda-files :maxlevel . 2)
        (,(list (concat user-emacs-directory "init.org")) :maxlevel . 3)
        ;; (+personal-org-roam-files+ :maxlevel . 2)
        )
      ;; Without this, completers like ivy/helm are only given the first level of
      ;; each outline candidates. i.e. all the candidates under the "Tasks" heading
      ;; are just "Tasks/". This is unhelpful. We want the full path to each refile
      ;; target! e.g. FILE/Tasks/heading/subheading
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)
#+end_src

*** TODO refile by context

[[https://emacs.stackexchange.com/questions/24976/org-mode-can-you-set-up-context-dependent-refile-targets][related Q]]

** the todo-keywords cycle
Track state changes.
+ ! :: timestamp 
+ @ :: timestamp with note

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "MAYBE(m@)" "TODO(t)" "IN-PROGRESS(i@)" "STUCK(z@/@)" "|" "DONE(d@)" "CANCELLED(c@)")
        (sequence "REPORT(r)" "BUG(b/@)" "KNOWNCAUSE(k@)" "|" "FIXED(f)")
        (sequence "STUDY(s)" "|" "STUDIED(S@)" "ARCHIVED(a@)")
        ))
#+end_src


#+begin_src emacs-lisp
(setq org-stuck-projects
      ;; identify a project with TODO keywords/tags
      ;; identify non-stuck state with TODO keywords
      ;; identify non-stuck state with tags
      ;; regexp match non-stuck projects
      '("-moyu&-MAYBE" ("TODO" "IN-PROGRESS" "BUG" "KNOWNCAUSE") nil ""))
#+end_src

** export

*** disable toc by default

#+begin_src emacs-lisp

(setq org-export-with-toc nil)
#+end_src

*** latex classes

**** beamer

temporary: yanked from
http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html
which improves upon
[[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg17712.html]]

org-mode tutorial on beamer
https://orgmode.org/worg/exporters/beamer/tutorial.html

#+begin_src emacs-lisp :tangle nil
;; allow for export=>beamer by placing

;; #+LaTeX_CLASS: beamer in org files
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))
(add-to-list 'org-latex-classes
	     ;; beamer class, for presentations
	     '("beamer"
	       "\\documentclass[11pt]{beamer}\n
      \\mode<{{{beamermode}}}>\n
      \\usetheme{{{{beamertheme}}}}\n
      \\usecolortheme{{{{beamercolortheme}}}}\n
      \\beamertemplateballitem\n
      \\setbeameroption{show notes}
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{hyperref}\n
      \\usepackage{color}
      \\usepackage{listings}
      \\usepackage{physics}
      \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\\color{blue}\\bfseries,
  commentstyle=\\color{red},
  }\n
      \\usepackage{verbatim}\n
      \\institute{{{{beamerinstitute}}}}\n          
       \\subject{{{{beamersubject}}}}\n"

	       ("\\section{%s}" . "\\section*{%s}")

	       ("\\begin{frame}[fragile]\\frametitle{%s}"
		"\\end{frame}"
		"\\begin{frame}[fragile]\\frametitle{%s}"
		"\\end{frame}")))

;; letter class, for formal letters

(add-to-list 'org-latex-classes
	     '("letter"
	       "\\documentclass[11pt]{letter}\n
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{color}"

	       ("\\section{%s}" . "\\section*{%s}")
	       ("\\subsection{%s}" . "\\subsection*{%s}")
	       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	       ("\\paragraph{%s}" . "\\paragraph*{%s}")
	       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


#+end_src

** the sidebar

#+begin_src emacs-lisp

(use-package org-sidebar)

(defhydra org-sidebar (org-mode-map "C-c l")
  "sidebar"
  ("t" #'org-sidebar-tree-toggle "tree")
  ("s" #'org-sidebar-toggle "default sidebar")
  )
#+end_src

** babel
*** basic settings

#+begin_src emacs-lisp

(setq org-confirm-babel-evaluate nil)
(setq org-src-window-setup 'other-window)

;; display/update images in the buffer after I evaluate
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)

#+end_src

Indentation:
=org-return= should respect the language of src blocks (indentation in
=python=, as an example).

#+begin_src emacs-lisp

;; additional identation relative to #begin_src token
(setq org-edit-src-content-indentation 0)
(setq org-src-tab-src-acts-natively t)
;; leading whitespace not preserved on export
(setq org-src-preserve-indentation nil)
#+end_src

solution adopted from
https://emacs.stackexchange.com/questions/5850/how-to-auto-format-the-source-code-block-in-org-mode:

#+begin_src emacs-lisp

(defun indent-org-block-automatically ()
  (when (org-in-src-block-p)
    (org-edit-special)
    (indent-region (point-min) (point-max))
    (org-edit-src-exit)))

(run-at-time 1 5 'indent-org-block-automatically)
#+end_src

*** languages

Include languages: 
#+begin_src emacs-lisp
(use-package ob-ipython)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (shell . t)
   (java . t)
   (C . t)
   (clojure . t)
   (js . t)
   (ditaa . t)
   (dot . t)
   (org . t)
   (latex . t)
   (haskell . t)
   (ditaa . t)
   (ipython . t) 			;; provided by package ob-ipython
   ))

#+end_src

Set command for python (Ubuntu 20.04 symlinks python to python2.7, so
the default settings calls python2.7).
#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

#+begin_src python :results output :tangle nil

import sys
print(sys.version)
#+end_src

use the python lexer for ipython blocks:

#+begin_src emacs-lisp

(unless (boundp 'org-latex-minted-langs)
  (setq org-latex-minted-langs nil))
(add-to-list 'org-latex-minted-langs '(ipython "python"))
#+end_src

*** keymap

[[https://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/][use src-block major-mode keymap inside src block]]

#+begin_src emacs-lisp
(use-package elpy)
(use-package lispy)

(setq scimax-src-block-keymaps
      `(("ipython" . ,(let ((map (make-composed-keymap
                                  `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                  org-mode-map)))
                        ;; In org-mode I define RET so we f
                        (define-key map (kbd "<return>") 'newline)
                        (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                        map))
        ("python" . ,(let ((map (make-composed-keymap
                                 `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                 org-mode-map)))
                       ;; In org-mode I define RET so we f
                       (define-key map (kbd "<return>") 'newline)
                       (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                       map))
        ("emacs-lisp" . ,(let ((map (make-composed-keymap `(,lispy-mode-map
                                                            ,emacs-lisp-mode-map
                                                            ,outline-minor-mode-map)
                                                          org-mode-map)))
                           (define-key map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c)
                           map))))

(defun scimax-add-keymap-to-src-blocks (limit)
  "Add keymaps to src-blocks defined in `scimax-src-block-keymaps'."
  (let ((case-fold-search t)
        lang)
    (while (re-search-forward org-babel-src-block-regexp limit t)
      (let ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (if (assoc (org-no-properties lang) scimax-src-block-keymaps)
            (progn
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          scimax-src-block-keymaps))))
              (add-text-properties
               beg end `(cursor-sensor-functions
                         ((lambda (win prev-pos sym)
                            ;; This simulates a mouse click and makes a menu change
                            (org-mouse-down-mouse nil)))))))))))

(defun scimax-spoof-mode (orig-func &rest args)
  "Advice function to spoof commands in org-mode src blocks.
It is for commands that depend on the major mode. One example is
`lispy--eval'."
  (if (org-in-src-block-p)
      (let ((major-mode (intern (format "%s-mode" (first (org-babel-get-src-block-info))))))
        (apply orig-func args))
    (apply orig-func args)))

(define-minor-mode scimax-src-keymap-mode
  "Minor mode to add mode keymaps to src-blocks."
  :init-value nil
  (if scimax-src-keymap-mode
      (progn
        (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map)
        (add-to-list 'font-lock-extra-managed-props 'cursor-sensor-functions)
        (advice-add 'lispy--eval :around 'scimax-spoof-mode)
        (cursor-sensor-mode +1))
    (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
    (advice-remove 'lispy--eval 'scimax-spoof-mode)
    (cursor-sensor-mode -1))
  (font-lock-fontify-buffer))

;; (add-hook 'org-mode-hook (lambda ()
;;                             (scimax-src-keymap-mode +1)))

#+end_src

** latex

#+begin_src emacs-lisp
(use-package auctex
  :defer t)

(use-package cdlatex
  :hook (org-mode . turn-on-org-cdlatex))
#+end_src

Automatically toggle preview of latex fragments:

#+begin_src emacs-lisp

(use-package org-fragtog
  :after org)
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src

#+begin_src emacs-lisp
(straight-use-package
 '(engrave-faces
   :host github
   :repo "tecosaur/engrave-faces"
   :branch "master"))

(with-eval-after-load 'ox-latex
  (setq org-latex-listings 'engraved))
#+end_src

company backend for inline math:

#+begin_src emacs-lisp
(load-file (concat user-emacs-directory "lisp/my-org-extra.el"))
#+end_src

*** TODO rewrite clear cache
#+begin_src emacs-lisp
(defun langou/org-latex-delete-cache () (interactive)
       (delete-directory "~/.emacs.d/.local/cache/org-latex" :RECURSIVE t))
#+end_src

** ref

[[https://www.youtube.com/watch?v=2t925KRBbFc][tutorial video by the author]]
[[https://kitchingroup.cheme.cmu.edu/blog/2014/05/13/Using-org-ref-for-citations-and-references/#hautier-2012-accur][an introduction by the author]]
[[https://nickgeorge.net/science/org_ref_setup/][setting up and configuring org ref]]

frequently used commands:
- org-ref-helm-insert-label (it can recognize labels in LaTeX blocks!)
- org-ref-insert-link

#+begin_src emacs-lisp
(use-package org-ref
  :config
  ;; list of BibTex database files used
  (progn
    ;; The name of the BibTeX field in which the path to PDF files is stored
    (setq bibtex-completion-pdf-field "file")
    ;; and bibtex-completion will look up PDF in the directories
    ;; specifies by 'bibtex-completion-library-path
    (let* ((my-ref-bibtex
	    (mapcar #'file-truename
		    (list "~/Zot/mylib/references.bib"
			  "~/Zot/math/math.bib"
			  "~/canvassync/VR369/Assignments/leb.bib")))
	   (my-pdf-parent-dirs
	    (mapcar #'file-truename (list "~/Zot/mylib/"
					  "~/Zot/math/")))
	   (my-pdf-dirs
	    (seq-concatenate 'list
			     (mapcar
			      #'(lambda (dir) (directory-files-recursively dir "" t))
			      my-pdf-parent-dirs)))
	   )
      (setq reftex-default-bibliography my-ref-bibtex
	    org-ref-default-bibliography my-ref-bibtex
	    bibtex-completion-bibliography my-ref-bibtex
	    org-ref-pdf-directory my-pdf-parent-dirs
	    bibtex-completion-library-path my-pdf-parent-dirs)
      )
    ;; (setq org-ref-get-pdf-filename-function
    ;; 	  #'org-ref-get-pdf-filename-helm-bibtex)
    ;; (setq org-ref-notes-function 'org-ref-notes-function-many-files)
    ;; (setq bibtex-completion-pdf-open-function
    ;; 	  (lambda (fpath)
    ;; 	    (start-process "zathura_bibtex" "*zathura open pdf*" "zathura" fpath)))
    )
    )
#+end_src 
cite:hess_real-time_2016,diestelGraphTheory2006,mur-artal_orb-slam2_2017


#+begin_src emacs-lisp

(defun my/org-ref-open-pdf-at-point ()
  "Open the pdf for bibtex key under point if it exists."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
         (key (car results))
	 (pdf-cite:mur-artal_orb-slam2_2017file (car (bibtex-completion-find-pdf key))))
    (if (file-exists-p pdf-file)
	(org-open-file pdf-file)
      (message "No PDF found for %s" key))))

(setq org-ref-open-pdf-function 'my/org-ref-open-pdf-at-point)
#+end_src

In order for the export to work properly, the compilation of LaTeX
buffer should be changed!

#+begin_src emacs-lisp

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
	"bibtex %b"
	"pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
	"pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

** org-roam

Org-roam is a minor mode that manages backlinks.
With =org-roam-buffer-toggle-display=, the buffer with name specified by
=org-roam-buffer= shows the nodes that points to the current buffer.

#+begin_src emacs-lisp
(executable-find "sqlite3")
(use-package org-roam
  :commands org-roam-mode
  :init (add-hook 'after-init-hook 'org-roam-mode)
  :config
  (require 'org-ref)
  (progn
    ;; all subdirectories of org-roam-directory are considered part of
    ;; org-roam regardless of level of nesting.
    (setq org-roam-buffer "*org-roam-backlinks*")
    (setq org-roam-buffer-window-parameters
	  '((mode-line-format . nil)))
    (setq org-roam-directory (file-truename "~/org-roam"))
    (setq org-roam-tag-sources
	  (list
	   'prop
	   'last-directory)))

  (general-define-key
   :prefix "C-c r"
   "r" #'helm-bibtex
   "d" #'(lambda () (interactive)
	   (dired org-roam-directory))
   "s" #'(lambda () (interactive)
	   (progn
	     (org-roam-backlinks-mode t)
	     (org-roam-buffer-toggle-display)))
   "c" #'org-roam-db-build-cache
   "f" #'org-roam-find-file
   "y" #'org-roam-dailies-find-yesterday
   "x" #'org-roam-dailies-find-today
   "j" #'org-roam-dailies-capture-today
   "i" #'org-roam-insert)
  )
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-server
  :ensure t
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))
#+end_src

For 'org-roam-dalies' to work, several variables should be set.  The
'org-roam-dailies-directory' is by default understood as subdirectory
of the root 'org-roam-directory'.

It's importance to notice that org-roam's templating system is /not/
compatible with regular 'org-capture'. In fact, improvment have been
made to allow string prefilling:

#+begin_quote
   In org-roam templates, the =${var}= syntax allows for the expansion
of variables, stored in ‘org-roam-capture--info’.  For example, during
‘org-roam-insert’, the user is prompted for a title. Upon entering a
non-existent title, the ‘title’ key in ‘org-roam-capture--info’ is set
to the provided title.  =${title}= is then expanded into the provided
title during the org-capture process.  Any variables that do not contain
strings, are prompted for values using ‘completing-read’.
#+end_quote

Fuzzy search 'org roam template' in =describe variable= for customizable
template brought with org-roam.

#+begin_src emacs-lisp

(setq org-roam-dailies-directory "daily/")

(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")))
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :after org-roam
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)) ; optional: if Org Ref is not loaded anywhere else, load it here

(setq org-file-apps '((auto-mode . emacs)
                      ("\\.mm\\'" . default)
                      ("\\.x?html?\\'" . default)
                      ("\\.pdf\\'" . "zathura %s")))
#+end_src

** TODO org-capture: define entries separately 
[2020-12-24 四] A wired phenomena that I just found is that the
result of using defvar and using string for filename directly is
different!  If I use defvar after =file+headline=, the filename is
understood as a file in the relative path and something like
=~/vanilla/just-for-fun.org= is created (clearly the evaluation
happens in the org file in =~/vanilla=. However, if a string
="just-for-fun.org"= is given instead, Emacs understands it as a file
in my org-directory.

   #+begin_src emacs-lisp
   (defvar +org-capture-journal-file+ "journal.org")
   (defvar +org-capture-todo-file+ "todo.org")
   (defvar +org-capture-notes-file+ "notes.org")
   (defvar +org-capture-just-for-fun-file+ "just-for-fun.org")

   ;;;; org-journal
   (global-set-key (kbd "C-c j") #'(lambda ()
                                     (interactive)
                                     (find-file
                                      (concat org-directory "/journal.org"))))

   (global-set-key (kbd "C-c c") #'org-capture)
   (global-set-key (kbd "H-c") #'org-capture)

   (setq org-capture-templates
         '(("t" "Personal todo" entry
            (file+headline "todo.org" "Inbox")
            "* TODO %?\n%i" :prepend t)

           ("n" "Personal notes" entry
            (file+headline "notes.org" "Inbox")
            "* %U %?\n%i\n%a" :prepend t)

           ("f" "Maybe it would be fun someday..." entry
            (file+headline "just-for-fun.org" "Inbox")
            "* MAYBE %U %?" :prepend t)

           ;; declare root node j
           ("j" "Journal")

           ("ja" "Journal arbitrary recording" entry
            (file+olp+datetree "journal.org")
            "* %?\n%U\n%i" :tree-type week)

           ("jc" "journal clock into something new" entry
            (file+olp+datetree "journal.org")
            "* %?" :clock-in t :clock-keep t :tree-type week)

           ("jn" "journal edit the task currently clocked in" plain
            (clock) "%?" :unnarrowed t)

           ("r" "read later" checkitem
            (file+headline "read-later.org" "Inbox")
            "[ ] %? ")

           ("b" "bug" entry
            (file+headline "bug.org" "Inbox")
            "* BUG %^{header}\n%U\n#+begin_src\n\n%i\n\n#+end_src\n%?")

           ("v" "vocabularies" entry
            (file+headline "voc.org" "inbox")
            "* %<%Y-%m-%d %H:%M:%S>\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Basic\n:ANKI_DECK: langou gre\n:END:\n** Front\n%?\n** Back\n%i\n")))

   (require 'org-projectile)
   (push (org-projectile-project-todo-entry) org-capture-templates)
   #+end_src

** org-agenda
#+begin_src emacs-lisp
(setq org-agenda-files (apply (function append)
			      (mapcar
			       (lambda (directory)
				 (directory-files-recursively directory org-agenda-file-regexp))
			       '("~/org/"))))
#+end_src

** habit
#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit)
(global-set-key (kbd "s-a") #'org-agenda)
#+end_src

** completion 

#+begin_src emacs-lisp

(add-to-list 'org-modules 'org-tempo)
(setq org-structure-template-alist
      '(("a" . "export ascii\n")
	("c" . "center\n")
	("C" . "comment\n")
	("e" . "src emacs-lisp\n")
	("cp" . "src cpp\n")
	("py" . "src python\n")
	("sh" . "src shell")
	("ex" . "example")
	("E" . "export")
	("h" . "export html\n")
	("l" . "export latex\n")
	("q" . "quote\n")
	("s" . "src")
	("v" . "verse\n")
	;; org latex stuff
	("pf" . "proof")
	("th" . "theorem")
	("le" . "lemma")
	("pr" . "proposition")))
#+end_src

** pdf

[[https://www.youtube.com/watch?v=zqc-CWm4DGE&feature=emb_logo][org pdftools workflow]]
[[https://www.youtube.com/watch?v=LFO2UbzbZhA][another one]]

#+begin_src emacs-lisp

(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))

(use-package org-noter)

(use-package org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

open current pdf file in zathura.

#+begin_src emacs-lisp
(defun pdf-open-with-zathura ()
  "Use zathura to open file related to current buffer"
  (interactive)
  (async-shell-command
   (concat "zathura "
	   (buffer-file-name (current-buffer)))))
#+end_src

Also, add a dired embark action to open pdf/docx in external applications.

** misc
*** TODO shortkey conflict 
shortkey of org-mark-ring-goto conflicts with yasnippet.

* academic writing

** zotero integration

#+begin_src emacs-lisp
(use-package zotxt
  :after org
  :config
  (org-zotxt-mode t)
  )
#+end_src

* miscellaneous

** hl-todo

#+begin_src emacs-lisp

(use-package hl-todo
  :config
  (setq hl-todo-keyword-faces
	'(("TODO" . "#FF0000")))
  (add-hook #'prog-mode-hook #'(lambda ()
				 (hl-todo-mode t))))

#+end_src

** drop down emacs frame

#+begin_src emacs-lisp

(use-package yequake)

(setq yequake-frames
      '(("aba" .
	 ((width . 0.75)
	  (height . 0.5)
	  (alpha . 0.90)
	  (buffer-fns .  (org-roam-dailies-find-today
			  split-window-horizontally
			  (find-file "~/org/reading-list.org")))
	  (frame-parameters . ((undecorated . t)))))))

#+end_src

Or write my own...

#+begin_src emacs-lisp
(defun my-aba-float ()
  (progn  (select-frame (make-frame '((name . "aba")
				      (alpha . 80))))
	  (find-file "~/org/reading-list.org")
	  (split-window-horizontally)
	  (org-roam-dailies-find-today)))
#+end_src

And in =sxhkdrc=, do

#+begin_example
super + e
        emacsclient -n -e '(my-aba-float)'
#+end_example

** lorem ipsum

#+begin_src emacs-lisp

(use-package lorem-ipsum)
#+end_src

** set debug on error, load custom

#+begin_src emacs-lisp

(setq debug-on-error nil)
(setq custom-file (concat user-emacs-directory "custom.el"))
(load custom-file)

#+end_src

** default browser

For firefox:
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
#+end_src

As I've recently (as of Feb2021) switched to =qutebrowser=, I'd like to
have
#+begin_src emacs-lisp :tangle nil
(setq browse-url-generic-program "qutebrowser")
(setq browse-url-browser-function #'browse-url-generic)
#+end_src

** command-log

#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src
  
** ligature

#+begin_src emacs-lisp

(defconst lisp--prettify-symbols-alist
  '(("lambda"  . ?λ)))

(add-hook 'lisp-mode-hook #'(lambda () (interactive)
			      (prettify-symbols-mode +1)))


(setq python-prettify-symbols-alist
      (list
       '("lambda"  . ?λ)
       '("**2" . ?²)
       '("sum" . ?∑)
       '("sigma" . ?σ)
       '("rho" . ?ρ)
       '("mu" . ?μ)
       '("theta" . ?θ)
       '("_0" . ?₀)
       '("_1" . ?₁)
       '("_2" . ?₂)
       ))

(add-hook 'python-mode-hook #'prettify-symbols-mode)

#+end_src

** bookmarks and registers

#+begin_src emacs-lisp

(add-hook 'kill-emacs-hook #'bookmark-save)
(global-set-key (kbd "μ") #'bookmark-jump)
#+end_src

#+begin_src emacs-lisp

(global-set-key (kbd "H-j") #'jump-to-register)
(global-set-key (kbd "H-SPC") #'point-to-register)

#+end_src

Bookmarks in Emacs are similar in spirit to registers.

Unlike marks in vim (usually bound to m and '), which are limited to
independent buffers, registers allows one to jump across buffers or
persistent window layouts.

frequently used register commands:
- C-x r s <register> :: copy region
- C-x r SPC <register> :: save cursor position in some buffer
- C-x r w <register> :: save window config in selected frame
- C-x r f <register> :: save window config in *all* frames
- C-x r j <register> :: restore window config/cursor position
- C-x r r <register> :: copy region-rectangle
- C-x r i <register> :: insert region/rectangle

** mode management

#+begin_src emacs-lisp

(use-package helm-mode-manager
  :after helm)

#+end_src

** dictionary and web search

#+begin_src emacs-lisp

(use-package search-web)
(use-package wordnut
  :config
  (define-key wordnut-mode-map (kbd "g") #'wordnut))
(setq search-web-engines
      '(
        ("duck" "https://duckduckgo.com/?q=%s" nil)
        ("github" "https://github.com/search?q=%s" nil)
        ("google" "http://www.google.com/search?q=%s" nil)
        ("google scholar" "https://scholar.google.co.jp/scholar?q=%s" nil)
        ("youtube" "http://www.youtube.com/results?search_type=&search_query=%s&aq=f" External)
        ("emacswiki" "http://www.google.com/cse?cx=004774160799092323420%%3A6-ff2s0o6yi&q=%s&sa=Search" nil)
        ("wikipedia en" "http://www.wikipedia.org/search-redirect.php?search=%s&language=en" nil)
        ("stackoveflow en" "http://stackoverflow.com/search?q=%s" nil)
        ))

(defhydra define (global-map "s-d")
  "define"
  ("w" wordnut-search "wordnet")
  ("i" search-web "web search")
  ("m" man "man")
  )

#+end_src

** transparency

Interactively toggle transparency in winframe.
#+begin_src emacs-lisp

(defun transparency (value)
  "sets the transparency of the frame window. 0=transparent/100=opaque"
  (interactive "ntransparency value 0 - 100 opaque:")
  (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

Transparency at start:

#+begin_src emacs-lisp

(defvar +frame-transparency+ '(95 95))
(add-to-list 'default-frame-alist `(alpha . ,+frame-transparency+))

#+end_src

** cursor in =-nw= mode

currently disabled as I'm not using evil.
#+begin_src emacs-lisp :tangle nil

(unless (display-graphic-p)
  (require 'evil-terminal-cursor-changer)
  (evil-terminal-cursor-changer-activate) ; or (etcc-on)
  )
#+end_src

** focused editing

#+begin_src emacs-lisp

(use-package olivetti
  :config
  (progn
    ;; occupies 7/10 of the window width  
    (setq-default olivetti-body-width 0.7)
    )
  :bind (("C-c f e" . olivetti-mode)))

#+end_src

** expand-region.el

#+begin_src emacs-lisp

(use-package expand-region
  :config
  (progn
    (global-set-key (kbd "C-=") #'er/expand-region)
    ))
#+end_src

** remove unused UI components

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(setq use-file-dialog nil)
(setq use-dialog-box t)               ; only for mouse events
;; (setq inhibit-splash-screen t)
#+end_src

** copy filename

From Doom Emacs. Naming is altered to be consistent with Emacs terms
(yank -> save-to-king-ring).

#+begin_src emacs-lisp

(defun +default/save-to-king-ring-buffer-filename ()
  "Copy the current buffer's path to the kill ring."
  (interactive)
  (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
      (message (kill-new (abbreviate-file-name filename)))
    (error "Couldn't find filename in current buffer")))

(global-set-key (kbd "C-c k f")  #'+default/save-to-king-ring-buffer-filename)
#+end_src

** make all prompts y or n

#+begin_src emacs-lisp

(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** yaml

#+begin_src emacs-lisp

(use-package yaml-mode)
#+end_src

** integration with pywal

#+begin_src emacs-lisp :tangle nil

(straight-use-package
 '(theme-magic
   :host github
   :repo "jcaw/theme-magic"
   :branch "wal-theme-template"))

(straight-use-package
 '(xresources-theme
   :host github
   :repo "cqql/xresources-theme"))
#+end_src

** exec path from shell

#+begin_src emacs-lisp

(use-package exec-path-from-shell
  :config
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))
#+end_src

** hex color

#+begin_src emacs-lisp

(use-package rainbow-mode)

#+end_src

** chinese input method

#+begin_src emacs-lisp
(use-package pyim
  :ensure nil
  :config
  (use-package pyim-basedict
    :ensure nil
    :config (pyim-basedict-enable))
  ;; quanpin
  (setq pyim-default-scheme 'quanpin)
  (pyim-isearch-mode 1)
  (setq pyim-page-tooltip 'posframe)
  (setq pyim-page-length 5)
  (add-hook 'emacs-startup-hook
            #'(lambda () (pyim-restart-1 t)))
  )
#+end_src

* lsp

** basic

- find definitions :: 'C-x 4 .', 'M-.',  'C-x 5 .'
- find references :: 'M-?'
- definition glance (lsp-ui) :: 'ρ h g'

#+begin_src emacs-lisp

(use-package lsp-mode)

(use-package flycheck)

(use-package lsp-ui
  :after lsp-mode
  :demand flycheck
  )

(use-package lsp-python-ms
  :init (setq lsp-python-ms-auto-install-server t
              read-process-output-max 1048576)
  ;; :hook (python-mode . (lambda ()
  ;;                        (require 'lsp-python-ms)
  ;;                        (lsp)))
  )

#+end_src

** keybinding

#+begin_src emacs-lisp

(define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
(define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)

#+end_src

** ui tweaking

#+begin_src emacs-lisp

(setq lsp-ui-doc-enable nil)
(setq lsp-enable-links nil)
(setq lsp-headerline-breadcrumb-enable nil)
(setq lsp-signature-render-documentation nil)
(setq lsp-ui-sideline-show-diagnostics t)
(setq lsp-ui-sideline-show-hover nil)
(setq lsp-eldoc-render-all nil)

#+end_src

** scroll -> freeze fix

Whenever I try to scroll down (using mouse) until the bottom in a
lsp-ui-doc childframe, the cpu usage rises to 100% and Emacs freezes.

#+begin_src emacs-lisp

(setq
 mouse-wheel-scroll-amount
 '(1
   ((shift) . 1))
 mouse-wheel-progressive-speed nil)

(general-define-key
 :maps 'lsp-mode-map
 "C-c u i" #'lsp-ui-imenu
 "C-c d" #'lsp-ui-doc-focus-frame)
#+end_src

** helm integration

#+begin_src emacs-lisp

(use-package helm-lsp
  :after (lsp helm))

#+end_src

* music
** basic setup for emms

- s :: stop
- n :: next

#+begin_src emacs-lisp
(use-package emms
  :config
  (progn
    (emms-all)
    (emms-default-players)
    (setq emms-source-file-default-directory "~/Music")
    (setq emms-player-mplayer-parameters
	  '("-slave" "-quiet" "-really-quiet" "-novideo"))))

(global-set-key (kbd "C-c m m") #'emms)
(global-set-key (kbd "C-c m p") #'emms-add-playlist)
#+end_src

** TODO improve config
+ block mplayer from poping up

* rss, e-books and documents

** pdf

#+begin_src emacs-lisp
(straight-use-package
 '(pdf-tools :host github :repo "vedang/pdf-tools")
 )
(pdf-tools-install)
(setq pdf-view-midnight-colors
      '("#cccccc" . "#000000"))

#+end_src

#+begin_src emacs-lisp
(general-define-key
 :keymaps 'pdf-view-mode-map
 "o" #'pdf-outline
 "j" #'pdf-view-next-line-or-next-page
 "k" #'pdf-view-previous-line-or-previous-page
 "]" #'pdf-view-next-page-command
 "[" #'pdf-view-previous-page-command
 "/" #'pdf-occur)
#+end_src

frequently used commands for movement:
- f
- m and '
- /
- SPC S-SPC

** TODO epub, djvu, mobi

#+begin_src emacs-lisp

(use-package nov
  :config
  (progn
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    ))
#+end_src

** elfeed

#+begin_src emacs-lisp :tangle nil

(use-package elfeed)
(global-set-key (kbd "C-x w") #'elfeed)
(setq elfeed-feeds
      '(
        ("https://www.motorsport.com/rss/f1/news/" motorsport)
        ("http://finance.yahoo.com/rss/headline?s=MSFT" finance)
	("https://feeds.bloomberg.com/politics/news.rss" bloomberg-politics)
        ))
#+end_src

* shell and term

** vterm

#+begin_src emacs-lisp

(use-package vterm)
(general-define-key
 :keymaps 'vterm-copy-mode-map
 "q" #'vterm-copy-mode)

(setq vterm-max-scrollback 10000)
#+end_src

#+begin_src emacs-lisp :tangle nil

(use-package vterm-toggle
  :bind
  ("s-v" . vterm-toggle)
  ("s-V" . vterm-toggle-cd)
  )
#+end_src

=multi-vterm=, the vterm derivative of [[https://www.emacswiki.org/emacs/multi-term.el][multi-term.el]], provides the toggle
of a dedicated vterm buffer and quick switch between vterm buffers.

#+begin_src emacs-lisp

(use-package multi-vterm
  :after vterm)

(global-set-key (kbd "s-v") #'multi-vterm-dedicated-toggle)

;; (global-set-key (kbd "s-v v") #'multi-vterm)
;; (defhydra multi-vterm (vterm-mode-map "s-v")
;;   "multi-vterm"
;;   ("d" #'multi-vterm-dedicated-toggle "dedicated")
;;   ("n" #'multi-vterm-next "next")
;;   ("p" #'multi-vterm-prev "prev")
;;   ("s" #'multi-vterm-dedicated-select "select as dedicated")
;;   ("r" #'multi-vterm-rename-buffer "rename")
;;   )

(setq multi-vterm-dedicated-window-height 30)

#+end_src

** eshell

*** eshell toggle

#+begin_src emacs-lisp

(use-package eshell-toggle)
(global-set-key (kbd "s-e") #'eshell-toggle)
#+end_src

*** git prompt

#+begin_src emacs-lisp

(use-package eshell-git-prompt
  :config
  (progn
    (eshell-git-prompt-use-theme 'robbyrussell)
    ))
#+end_src

*** keybinding

#+begin_src emacs-lisp

(global-set-key (kbd "s-e") #'eshell)

#+end_src

[[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell pop up window]]

#+begin_src emacs-lisp :tangle nil
(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (height (/ (window-total-height) 3))
         (name   (car (last (split-string parent "/" t)))))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))

    (insert (concat "ls"))
    (eshell-send-input)))

(global-set-key (kbd "s-e") 'eshell-here)

(defun eshell/x ()
  (insert "exit")
  (eshell-send-input)
  (delete-window))
#+end_src

*** PATH

#+begin_src emacs-lisp

(setenv "PATH"
	(concat
	 ;; manually added
	 "/usr/local/cbc/bin" ";"
	 "~/.local/bin" ";"
	 (getenv "PATH")			; inherited from OS
	 )
	)

#+end_src

*** alias

The 'alias' command in eshell defines aliases sotre in
=eshell-alias-file=, which is inside the =user-emacs-directory= by
default.

#+begin_quote

   Note that unlike aliases in Bash, arguments must be handled
explicitly.  Typically the alias definition would end in ‘$*’ to pass
all arguments along.  More selective use of arguments via ‘$1’, ‘$2’,
etc., is also possible.  For example, ‘alias mcd 'mkdir $1 && cd $1'’
would cause ‘mcd foo’ to create and switch to a directory called
‘foo’.
#+end_quote

* modeline config

[[https://occasionallycogent.com/custom_emacs_modeline/index.html][A tutorial]]
[[info:emacs#Mode Line][info:emacs#Mode Line]]
[[help:mode-line-format]]

** 3d

#+begin_src emacs-lisp

(set-face-attribute 'mode-line nil :box t)
#+end_src

** the default

CS:CH-FR BUF  POS LINE (MAJOR MODE)
+ CS :: coding system.
+ ':' :: eol convention. Unix by default (on my XPS15 9500 running
  Linux). One may also choose Mac or DOS.
+ &optional @ :: for emacsclient.
+ CH :: change(?) 
+ '-' :: becomes '@' if the current buffer is on a remote machine.
+ FR :: only appears on text terminals
+ BUFF :: name of buffer.
+ POS :: position in the buffer.
  
#+begin_src emacs-lisp

(defun mode-line-format-raw ()
  (interactive)

  (setq mode-line-format
        '("%e" mode-line-front-space mode-line-mule-info mode-line-client
          mode-line-modified mode-line-remote
          mode-line-frame-identification
          mode-line-buffer-identification " " mode-line-position
          (vc-mode vc-mode)
          "  " mode-line-modes mode-line-misc-info mode-line-end-spaces)
	))
#+end_src

** diminish

#+begin_src emacs-lisp

(use-package diminish)
(diminish 'ivy-mode)
(diminish 'auto-revert-mode)
(diminish 'yas-minor-mode)
(diminish 'which-key-mode "which?")
(diminish 'org-indent-mode)
(diminish 'org-roam-mode)
(diminish 'org-cdlatex-mode "cd")
(diminish 'company-mode)
(diminish 'projectile-mode)
(diminish 'helm-mode)
(diminish 'auto-fill-function "AuF")
(diminish 'evil-snipe-mode)
(diminish 'evil-escape-mode)
#+end_src

** doom modeline

#+begin_src emacs-lisp 

(use-package doom-modeline
  ;; :init (doom-modeline-mode 1)
  :config
  (progn
    (setq doom-modeline-height 15)))

#+end_src

** nyan

#+begin_src emacs-lisp

(use-package nyan-mode
  ;; :config
  ;; (nyan-mode)
  ;; (nyan-start-animation)
  )
#+end_src

* ROS

#+begin_src emacs-lisp :tangle nil

(add-to-list 'load-path "/opt/ros/noetic/share/emacs/site-lisp")
(require 'rosemacs-config)
#+end_src

#+begin_src emacs-lisp

(use-package helm-catkin)

#+end_src

gazebo simulation files:

#+begin_src emacs-lisp

(add-to-list 'auto-mode-alist '("\\.world\\'" . xml-mode))
(add-to-list 'auto-mode-alist '("\\.launch\\'" . xml-mode))
#+end_src

* learning by repetition

** pamparam
:PROPERTIES:
:header-args: :tangle nil
:END:

#+begin_src emacs-lisp

(use-package pamparam
  :after org)

#+end_src

** anki

anki-editor provides anki-integration with org-mode.
see [[*org-capture]] for capture-templates creating anki entries.

#+begin_src emacs-lisp

(use-package anki-editor)
#+end_src

* rainbow delimiters

#+begin_src emacs-lisp

(use-package rainbow-delimiters)
#+end_src

* programming languages

#+begin_src emacs-lisp
(global-set-key (kbd "H-r") #'compile)
(global-set-key (kbd "σ") #'compile)
#+end_src

code navigation:

#+begin_src emacs-lisp

(use-package imenu-anywhere)
(global-set-key (kbd "C-.") #'imenu-anywhere)
#+end_src

** TODO autoinsert

** autopair

#+begin_src emacs-lisp

(use-package autopair)
(add-hook 'python-mode-hook #'autopair-mode)
#+end_src


** lisp-general

#+begin_src emacs-lisp

(use-package lispy)
(use-package evil-lispy)
#+end_src

#+begin_src emacs-lisp

(use-package paren-face)
(add-hook 'emacs-lisp-mode-hook (lambda () (paren-face-mode 1)))
(add-hook 'emacs-lisp-mode-hook (lambda () (autopair-mode 1)))

(use-package highlight-parentheses)
(add-hook 'emacs-lisp-mode-hook (lambda () (highlight-parentheses-mode 1)))

#+end_src

** racket

#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** rust

#+begin_src emacs-lisp
(use-package rust-mode
  :config
  (add-hook 'rust-mode-hook (lambda ()
			      (setq indent-tabs-mode nil))))
#+end_src

** wolfram

#+begin_src emacs-lisp
(use-package wolfram-mode
  :config
  (setq wolfram-path "~/.Mathematica/Applications")
  (add-to-list 'auto-mode-alist
	       '("\\.wl\\'" . wolfram-mode))
  )
#+end_src

** cmake

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

** python

#+begin_src emacs-lisp

(use-package elpy)
;; (elpy-enable)
(use-package jedi)

(use-package python-pytest)
(evil-define-key 'normal python-mode-map (kbd "SPC t") #'python-pytest-dispatch)

;; for font-lock and filling paragraphs inside docstring region:
(use-package python-docstring)

;; for generating docstring of a defun whenever needed
(use-package sphinx-doc)
(add-hook 'python-mode-hook #'(lambda ()
				(sphinx-doc-mode t)
				))
#+end_src

** C/C++

*** basic settings

#+begin_src emacs-lisp
(defun c-mode-my-basic-settings ()
  (progn
    (linum-mode t)
    (autopair-mode t)))

(add-hook 'c-mode-hook #'c-mode-my-basic-settings)
(add-hook 'c++-mode-hook #'c-mode-my-basic-settings)

#+end_src

*** formating

#+begin_src emacs-lisp

(use-package clang-format)
#+end_src

*** ccls

#+begin_src emacs-lisp :tangle nil

(use-package ccls
  :config
  (progn
    (setq ccls-executable "/usr/local/bin/ccls")
    ))
#+end_src

*** irony
:PROPERTIES:
:header-args: :tangle nil
:END:

#+begin_src emacs-lisp

(use-package irony)

(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

(defun my-irony-mode-hook ()
  (define-key irony-mode-map [remap completion-at-point]
    'counsel-irony)
  (define-key irony-mode-map [remap complete-symbol]
    'counsel-irony))

(add-hook 'irony-mode-hook 'my-irony-mode-hook)

(use-package company-irony
  :after (irony company)
  :config
  (progn
    (add-to-list 'company-backends 'company-irony)
    ))

(use-package flycheck-irony
  :after (irony flycheck)
  :config
  (progn
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)
    ))

(add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
(setq company-backends (delete 'company-semantic company-backends))
(eval-after-load 'company
  '(add-to-list
    'company-backends 'company-irony))

(use-package irony-eldoc)
(add-hook 'irony-mode-hook #'irony-eldoc)
#+end_src

*** rtags
:PROPERTIES:
:header-args: :tangle nil
:END:

#+begin_src emacs-lisp

(setq rtags-completions-enabled t)
(eval-after-load 'company
  '(add-to-list
    'company-backends 'company-rtags))
(setq rtags-autostart-diagnostics t)

#+end_src

[[https://github.com/Andersbakken/rtags/wiki/Usage][wiki]]

**** navigation

#+begin_src emacs-lisp

(defun ciao-goto-symbol ()
  (interactive)
  (deactivate-mark)
  (ring-insert find-tag-marker-ring (point-marker))
  (or (and (require 'rtags nil t)
           (rtags-find-symbol-at-point))
      (and (require 'semantic/ia)
           (condition-case nil
               (semantic-ia-fast-jump (point))
             (error nil)))))
(define-key c++-mode-map (kbd "M-.") 'ciao-goto-symbol)
(define-key c++-mode-map (kbd "M-,") 'pop-tag-mark)
#+end_src

**** helm integration

#+begin_src emacs-lisp
(use-package rtags-xref)
(use-package company-rtags)
(use-package helm-rtags)
(setq rtags-use-helm t)

#+end_src

**** company integration

#+begin_src emacs-lisp

(setq company-idle-delay 0)
(define-key c-mode-map [(tab)] 'company-complete)
(define-key c++-mode-map [(tab)] 'company-complete)


(use-package company-irony-c-headers)
(eval-after-load 'company
  '(add-to-list
    'company-backends '(company-irony-c-headers company-irony)))

#+end_src

**** flycheck integration

#+begin_src emacs-lisp

;; (add-hook 'c++-mode-hook 'flycheck-mode)
;; (add-hook 'c-mode-hook 'flycheck-mode)
(use-package flycheck-rtags)
(defun my-flycheck-rtags-setup ()
  (flycheck-select-checker 'rtags)
  (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
  (setq-local flycheck-check-syntax-automatically nil))
;; c-mode-common-hook is also called by c++-mode
(add-hook 'c-mode-common-hook #'my-flycheck-rtags-setup)

#+end_src

**** keybinding

#+begin_src emacs-lisp

(defhydra rtags-movement (c-mode-base-map "ρ")
  "code navigation using rtags"
  ("ρ" #'rtags-find-symbol-at-point "gd")
  (":" #'rtags-diagnostics "diagnostics")
  )

#+end_src

*** cmake-ide
:PROPERTIES:
:header-args: :tangle nil
:END:

#+begin_src emacs-lisp

(use-package cmake-ide)
;; (cmake-ide-setup)
#+end_src

*** cpputils-cmake
:PROPERTIES:
:header-args: :tangle nil
:END:

#+begin_src emacs-lisp

(use-package cpputils-cmake)

(add-hook 'c-mode-common-hook
          (lambda ()
            (if (derived-mode-p 'c-mode 'c++-mode)
                (cppcm-reload-all)
              )))
;; OPTIONAL, somebody reported that they can use this package with Fortran
(add-hook 'c90-mode-hook (lambda () (cppcm-reload-all)))
;; OPTIONAL, avoid typing full path when starting gdb
(global-set-key (kbd "C-c C-g")
		'(lambda ()(interactive) (gud-gdb (concat "gdb --fullname " (cppcm-get-exe-path-current-buffer)))))
;; OPTIONAL, some users need specify extra flags forwarded to compiler
(setq cppcm-extra-preprocss-flags-from-user '("-I/usr/src/linux/include" "-DNDEBUG"))
#+end_src

** clojure

I don't actually write clojure but =lispy= tells me to have =cider=
installed (for overlay display of eval results...)

#+begin_src emacs-lisp

(use-package cider)
#+end_src

** TODO format on save:

* EXWM
:PROPERTIES:
:header-args: :tangle nil
:END:
** keybinding
Most keys defined in [[*window and buffer]] are configured as prefix-keys
in exwm windows.  s-<num> switches to <num> th workspace, although
workspace is never used with single monitor (of xps15).

C-p, C-n, C-b, C-f, C-a, C-e are set to send keys to exwm-windows
according to Emacs keybindings (similar to what happens in MacOS and
tweaked gnome).

Firefox provides caret-mode for keyboard-driven text-selection
(Shift + Movement to select). Together with =M-w= configured to send =C-c=
to the exwm-windows, a relatively consistent experience of copying is
achieved.

#+begin_src emacs-lisp 
(use-package exwm
  :config
  (progn
    (setq exwm-workspace-number 3)
    (setq exwm-input-prefix-keys
          `(?\C-x
            ?\s-o ;; switch-to-buffer
            ?\s-i ;; ibuffer
            ?\s-j ;; window switch
            ?\s-c ;; kill window
            ?\s-C ;; kill buffer and window(if not single)
            ?\s-k ;; window switch
            ?\s-v ;; vterm
            ?\s-s ;; single-window-toggle
            ?\s-e ;; eshell
            ?\s-q ;; toggle side windows
            ?\s-t ;; toggle touchpad
            ?\s-d ;; helm-wordnut
            ?\C-u ;; general command
            ?\C-h ;; help
            ?\M-x
            ?\M-&
            ?\M-:
            ?\H-c ;; org-capture
            ?\H-s ;; kill other windows
            ?\C-\ ))
    (setq exwm-input-global-keys
          `(([?\s-r] . exwm-reset)
            ([?\s-w] . exwm-workspace-switch)
            ([?\s-\;] . (lambda (command)
                          (interactive (list (read-shell-command "$ ")))
                          (start-process-shell-command command nil command)))
            ,@(mapcar (lambda (i)
                        `(,(kbd (format "s-%d" i)) .
                          (lambda ()
                            (interactive)
                            (exwm-workspace-switch-create ,i))))
                      (number-sequence 0 2))))
    (exwm-input-set-simulation-keys
     '(([?\C-b] . left)
       ([?\C-f] . right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-w] . [?\C-c])
       ;; ([?\M-b] . [?\C-?\<left>])
       ;; ([?\M-f] . [?\C-?\<left>])
       ))
    (setq exwm-workspace-warp-cursor t
          mouse-autoselect-window t
          focus-follows-mouse t)
    ;; (exwm-enable)
    ))
#+end_src

Ocassionly, key-sequences intercepted by Emacs can be send after C-q.
s-SPC runs #'counsel-linux-app and s-<tab> toggles tab selection.

#+begin_src emacs-lisp

  ;; After C-q, send key to the window 
  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
  (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)

#+end_src

** window configuring

#+begin_src emacs-lisp

(defun efs/run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(defun efs/exwm-init-hook ()

  (exwm-workspace-switch-create 0)

  ;; Start the Polybar panel
  (exwm-outer-gaps-mode)
  (efs/start-panel)

  ;; Launch apps that will run in the background
  ;; (efs/run-in-background "dunst")
  ;; (efs/run-in-background "nm-applet")
  ;; (efs/run-in-background "pasystray")
  ;; (efs/run-in-background "blueman-applet")

  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))
      )))

;; This function isn't currently used, only serves as an example how to
;; position a window
(defun efs/position-window ()
  (let* ((pos (frame-position))
	 (pos-x (car pos))
	 (pos-y (cdr pos)))
    (exwm-floating-move (- pos-x) (- pos-y))))

(defun efs/configure-window-by-class ()
  (interactive)
  (pcase exwm-class-name
    ("electron-ssr" (exwm-floating-toggle-floating))))

;; When EXWM starts up, do some extra confifuration
(add-hook 'exwm-init-hook #'efs/exwm-init-hook)

;; When window "class" updates, use it to set the buffer name
(add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

;; When window title updates, use it to set the buffer name
(add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

;; Configure windows as they're created
(add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

#+end_src

** useless gaps

[[https://github.com/lucasgruss/exwm-outer-gaps][the repo]] hasn't yet been submitted to MELPA.

#+begin_src emacs-lisp

(straight-use-package
 '(exwm-outer-gaps :host github :repo "lucasgruss/exwm-outer-gaps")
 )

(setq exwm-outer-gaps-width [25 25 25 25])
(global-set-key (kbd "H-G") #'exwm-outer-gaps-mode)
(global-set-key (kbd "C-c 1") #'exwm-outer-gaps-mode)

#+end_src

** desktop environment

Get more decent.

- Volume: amixer
- Brightness: brightnessctl
- Screenshot: scrot
- Screenlock: slock
- Keyboard backlight: upower
- Wifi and bluetooth: TLP
- Music: playerctl

#+begin_src emacs-lisp

(use-package desktop-environment)
(desktop-environment-mode)
#+end_src

** workspaces and monitors
Make sure xrandr update refresh EXWM frames.
Assign workspaces to monitors.
#+begin_src emacs-lisp
  (require 'exwm-randr)
  (setq exwm-randr-workspace-monitor-plist '(1 "DP-1-2" 1 "DP-2" 1 "DP-1-1" 1 "DP-1"))
  (exwm-randr-enable)
#+end_src

#+begin_src emacs-lisp
(defun efs/run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

(defun efs/update-displays ()
  (efs/run-in-background "autorandr --change --force")
  (message "Display config: %s"
	   (string-trim (shell-command-to-string "autorandr --current"))))

(add-hook 'exwm-randr-screen-change-hook #'efs/update-displays)
(efs/update-displays)

#+end_src

** wallpaper

#+begin_src emacs-lisp :tangle nil :eval never 

(defun wallpaper--scaling ()
  "Return the wallpaper scaling style to use."
  (cl-case wallpaper-scaling
    (scale "--bg-scale ")
    (max "--bg-max ")
    (fill "--bg-fill ")
    (tile "--bg-tile ")
    (center "--bg-center ")))
#+end_src

#+begin_src emacs-lisp

(unless (executable-find "feh")
  (display-warning 'wallpaper "External command `feh' not found!"))

;; This is an example `use-package' configuration
;; It is not tangled into wallpaper.el
(use-package wallpaper
  :ensure t
  :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
         (after-init . wallpaper-cycle-mode))
  :custom ((wallpaper-cycle-single t)
           (wallpaper-scaling 'fill)
           (wallpaper-cycle-interval 45)
           (wallpaper-cycle-directory "~/Pictures/Wallpapers")))

#+end_src

* save sessions

- desktop-save :: manual save
- desktop-save-mode :: non nil if the /mode/ is enabled
- desktop-change-dir :: save current desktop and reload one saved in
  another directory.
- desktop-revert :: reverts to the desktop /previously reloaded/.
- desktop-path :: list of directories to search for the desktop file.
- desktop-clear :: kills all buffers except internal ones, and clears
  the global variables listed in ‘desktop-globals-to-clear’. Variable
  can be set to preserve some buffers matching certain regexp.

  The =--no-desktop= option can be passed
  so that no saved desktop wouldn't be reloaded.

#+begin_src emacs-lisp

(setq desktop-save-mode nil)

#+end_src

* eaf

experimental.  By default it override some tools that I've been
familiar with (like pdf-tools).  Only used after manual execution of
code block.

#+begin_src emacs-lisp :tangle nil

(add-to-list 'load-path "~/vanilla/site-lisp/emacs-application-framework/")
(require 'eaf)
#+end_src

#+begin_src emacs-lisp :tangle nil :eval never

(use-package eaf
  :custom
  (eaf-browser-continue-where-left-off t)
  :config
  (eaf-setq eaf-browser-enable-adblocker "true")
  (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
#+end_src

* workflow

This is a special section dedicated to describe the ideal workflow
that this configuration seeks to provide. For easier maintenance it
shall not contain any source block to tangle.

** switch buffer

In EXWM, emacs buffer and application presented in X windows are
treated equally in buffer lists.

in =helm-buffer-list=, the list can be quickly narrowed with

- name of the buffer
- major mode via =*[pattern to match major mode]= or =*![pattern to match major mode]=
- directory with =/[pattern to match directory]= or '!' after '/' for negation
- include text via '@[pattern to match text]' or '!' after '@' for negation

#+begin_quote

‘helm-buffers-fuzzy-matching’ turns on fuzzy matching on buffer names, but not
on directory names or major modes.  A pattern starting with "^" disables fuzzy
matching and matches by exact regexp.

#+end_quote

Unfortunately, the content of other applications is not accessible to
emacs. Even for [[*eaf]] buffer, the content of webpage/pdf(?) is not accessible
to helm.

frequently used actions on buffer:
- C-c o :: open in other window
  
** maintenance

Periodic activities that clears whatever impedes progress along a
clean workflow. It remains to observe whether dedicatin into
maintenance could defy the meaning of its own existence.

- bookmark cleaning
- check agenda
- Youtube watche later achive to org
- read-later.org check

** code reading

- peep-dired + dired-subtree :: for brief grasp of file structure
- ;-m :: bookmark
- ? :: capture template for specific code

- s-p f :: helm-projectile-find-file
- s-f d :: rg-dwim
- s-f r :: regexp search in chosen directory
- C-c n :: hydra for code navigation (recently defined for python-mode only)

** debug

- ? :: solution from br
- H-c b / C-c c b :: capture bug from command line (requires manual
  selection)

** note taking 

explicate how objects of note-taking are classified and
located/refiled/archived.

** emacsclient + bspwm + tmux + firefox

* meta

Automatically tangle /this file/ on save.

#+begin_src emacs-lisp

(defun efs/org-babel-tangle-config ()
  (when (string-equal (file-name-directory (buffer-file-name))
                      (expand-file-name user-emacs-directory))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook
					      #'efs/org-babel-tangle-config)))
#+end_src
