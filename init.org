#+TITLE: init
#+PROPERTY: header-args :tangle init.el :results silent
#+startup: content

Some of the awesome configurations used as reference:

+ james cash :: [[https://github.com/jamesnvc/dotfiles]]
+ Protesilaos Stavrou :: https://protesilaos.com/dotemacs/
+ Doom Emacs :: [[https://github.com/hlissner/doom-emacs]]
+ Emacs from scratch series :: [[https://github.com/daviwil/emacs-from-scratch]]

* personal info

#+begin_src emacs-lisp

  (setq user-full-name "Jigang Li"
        user-mail-address "ljg16654@sjtu.edu.cn")
#+end_src

* server

#+begin_src emacs-lisp

(server-start)
#+end_src

* straight.el

#+begin_src emacs-lisp

  ;; each use-package form also invoke straight.el to install the package
  (setq straight-use-package-by-default t)
#+end_src

#+begin_src emacs-lisp

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

#+end_src

then, install =use-package= with straight.el:

#+begin_src emacs-lisp

  (straight-use-package 'use-package)
#+end_src

On usage of defer:
#+begin_quote

In almost all cases you don't need to manually specify :defer t. This
is implied whenever :bind or :mode or :interpreter is used. Typically,
you only need to specify :defer if you know for a fact that some other
package will do something to cause your package to load at the
appropriate time, and thus you would like to defer loading even though
use-package isn't creating any autoloads for you.
#+end_quote

* completion

'Emacs isn't Emacs without completion.'

** helm

*** setup

#+begin_src emacs-lisp

  (use-package helm
    :config
    (progn
      (helm-mode 1)
      ))
#+end_src


#+begin_src emacs-lisp

  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "s-o") #'helm-buffers-list)
  (global-set-key (kbd "s-O") #'helm-recentf)
  (global-set-key (kbd "M-i") #'helm-imenu)
  (global-set-key (kbd "C-h a") #'helm-apropos)
  (global-set-key (kbd "μ") #'helm-filtered-bookmarks)
  (global-set-key (kbd "C-s-SPC") #'helm-filtered-bookmarks)

#+end_src

** ivy, swiper and counsel

#+begin_src emacs-lisp :tangle nil

(use-package ivy
  :config
  (setq ivy-use-virtual-buffers t
	enable-recursive-minibuffers t)
  :bind (("C-s" . swiper)
	 ("C-c C-r" . ivy-resume)
	 ("M-x" . counsel-M-x)
	 ("C-x C-f" . counsel-find-file)))

(ivy-mode 1)
(define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)

#+end_src

** yasnippet
The snippets are currently stored in DOOMDIR and I may move them to somewhere else later.
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (progn
      (setq yas-snippet-dirs
            (list (concat user-emacs-directory "snippet/")))
      (yas-global-mode)))
#+end_src

** which key
#+begin_src emacs-lisp
  (use-package which-key
    ;; :init (which-key-mode)
    :config
    (setq which-key-idle-delay 0.3))
#+end_src

enhance ivy with ivy-rich: 
#+begin_src emacs-lisp :tangle nil
  (use-package ivy-rich
    :config (ivy-rich-mode +1))
#+end_src

** company delay

#+begin_src emacs-lisp

  (use-package company
    :config
    (setq company-idle-delay 0)
    )

  (add-hook 'after-init-hook 'global-company-mode)

#+end_src

** TAB behavior

https://stackoverflow.com/questions/7022898/emacs-autocompletion-in-emacs-lisp-mode

#+begin_quote

With this setup, TAB - which is usually bound to
indent-for-tab-command - first tries to adjust the indentation
according to the mode's settings, but if the indentation is already
correct, completion is triggered.
#+end_quote

#+begin_src emacs-lisp

  (setq tab-always-indent 'complete)
  (add-to-list 'completion-styles 'initials t)
#+end_src



* elisp

#+begin_src emacs-lisp

  (use-package dash)
  (use-package f)
#+end_src

* theme, font

[[https://stackoverflow.com/questions/21033270/resizing-echoarea-of-emacsclient][related issue on wired space at bottom]]

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :font "iosevka" :height 135)
#+end_src

[[https://protesilaos.com/modus-themes/][modus-theme manual]]

#+begin_src emacs-lisp

  (use-package anti-zenburn-theme
    :defer t)

  (use-package solarized-theme
    :defer t
    :config
    (progn
      (setq solarized-use-variable-pitch nil)))

  (use-package spacemacs-theme
    :defer t)

  (use-package apropospriate-theme)

  (use-package weyland-yutani-theme)

  (load-theme 'modus-vivendi t)
#+end_src

* keybinding and grouping commands

[[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][mastering key bindings emacs]]
/Function/ and /navigation/ keys, i.e. keys including F-keys, arrow keys
and home row keys, should be wrapped with =<= and =>=.

** general.el

For examples, see [[file:../org-roam/20210113022951-general_el_define_keybinding.org][general.el define keybinding]].

#+begin_src emacs-lisp

  (use-package general)
#+end_src

** evil

#+begin_src emacs-lisp
 
  (use-package evil)
  (use-package evil-escape
    :config
    (progn
      (setq-default evil-escape-key-sequence "jk")
      (evil-escape-mode)))

  (global-set-key (kbd "H-e") #'evil-mode)
#+end_src

** hydra

#+begin_src emacs-lisp

  (use-package hydra)
  (global-set-key (kbd "C-c h") #'hydra-pause-resume)
#+end_src

A minimalistic example:

#+begin_src emacs-lisp

  (defhydra landmark (global-map "C-c f")
    "landmarks"
    ("p" #'(lambda () (interactive)
             (find-file (concat user-emacs-directory "init.org")))
     "config")
    ("d" #'(lambda () (interactive)
             (dired "~/Downloads"))
     "downloads")
    ("c" #'(lambda () (interactive)
             (dired "~/Documents"))
     "documents")
    ("r" #'(lambda () (interactive)
             (dired "~/ROS"))
     "ros workspaces")
    ("y" #'(lambda () (interactive)
             (dired (concat user-emacs-directory "snippet/"))
             "snippets")))
#+end_src

* search/replace

Sometimes, when =lsp= doesn't work for some reasons (for example,
dependencies are not met on the machine and thus =cmake= cannot be
performed), it proves necessary to find definitions and references
through manual search.

Currently I'm experimenting with all kinds of choices in order to find

- best approach to finding symbol under cursor in project.
- difference between =project.el= (shipped with Emacs) and =projectile=.

** rg

In default bindings of =rg=, =C-c s= spawns a transient menu
similar to that of =magit=.
=s-f= is also bound to =rg-menu=.

Severals notes on the manual pages:
- =ripgrep= has it own configuration which is not encourage by =rg= as it
may easily bring about malfunction due to carelessness.
- The variable =rg-ignore-case= can be customized for case sensitivity.
- r :: =rg=. Interprets _query_ string as regexp.
- t :: =rg-literal=. Interprets _query_ string literally.
- p :: =rg-project=.
- d :: =rg-dwim=. Search in project by default while search in
  file/directory can be called with universal arguments.

The package also features isearch integration. While I'm considering
about migration from ivy to swiper, the integration is appended to
read later at the moment.

#+begin_src emacs-lisp

  (use-package rg
    :config
    (progn
      (rg-enable-default-bindings))
    :bind
    ("s-f" . rg-menu))

  ;; seems to be dependency for projectile-ripgrep
  (use-package ripgrep) 
#+end_src

** ag

#+begin_src emacs-lisp

  (use-package ag)
#+end_src

** Iedit

Available /inside a (possibly narrowed) buffer/. For cross-buffer multicursor editing, see [[* isearch, swiper, swoop]].

[[https://github.com/victorhge/iedit][Iedit repo]]
[[https://www.emacswiki.org/emacs/Iedit][EmacsWiki::Iedit]]

- start with C-;
- expand with M-{ or M-} (similar to =expand-region=)
- hide non-matching lines with C-'
- terminate with C-;

#+begin_src emacs-lisp

  (global-set-key (kbd "C-;") #'iedit-mode)

#+end_src

Used in combination with
- =narrow-to-defun= (C-x n d)
- =expand-region= (C-=)

** isearch, swiper, swoop

Despite being powerful enough, =isearch-forward= causes least distortion
to window layout. For such reason, the default keymap bound to C-s is
preserved.  In fact, this choice doesn't imply a farewell with helm in
terms of searching. With M-i, =helm-swoop= on the buffer can be called
during isearch (the keybinding makes some sense as I've bound M-i to
=imenu= normally, and one can think of swoop as an interface for the
outline of isearch result). By issuing M-i one more, the search will
be performed throughout all present buffers with =helm-multi-swoop-all=.

#+begin_src emacs-lisp

  (use-package helm-swoop)
  (global-set-key (kbd "C-s") #'isearch-forward)
  ;; enable whitespace to match arbitrary string that doesn't contain a newline
  ;; non-greedily
  ;; such behavior is, however, limited to non-regexp search
  (setq search-whitespace-regexp ".*?")
#+end_src

** regexp search and replace
https://protesilaos.com/dotemacs/#h:b67687ee-25a3-4bf4-a924-180ccb63c629

C-M-s or C-M-r prompts for regexp to search against. Alternatively,
use M-r for =isearch-toggle-regexp= during isearch.y


* windows and buffers

** window rules and management
*** monocle-window

From prot's dotEmacs. Defines a monocole layout similar to Tiling
window managers.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defvar prot/window-configuration nil
      "Current window configuration.
  Intended for use by `prot/window-monocle'.")

    (define-minor-mode prot/window-single-toggle
      "Toggle between multiple windows and single window.
  This is the equivalent of maximising a window.  Tiling window
  managers such as DWM, BSPWM refer to this state as 'monocle'."
      :lighter " [M]"
      :global nil
      (if (one-window-p)
          (when prot/window-configuration
            (set-window-configuration prot/window-configuration))
        (setq prot/window-configuration (current-window-configuration))
        (delete-other-windows)))
    :bind ("C-c s" . prot/window-single-toggle))
#+end_src

*** display-buffer-alist

[[https://protesilaos.com/dotemacs/#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][prot window rules]]
[[info:emacs#Window Choice][info:emacs#Window Choice]]

#+begin_src emacs-lisp

  (setq display-buffer-alist
        '(
          ("\\*\\(Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2)
           (window-parameters . ((no-other-window . t))))
          ;; bottom side window
          ("\\*\\(Completions\\|Embark Collect Live\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; left side window
          ("\\*Help.*"
           (display-buffer-in-side-window)
           (window-width . 0.20)       ; See the :hook
           (side . left)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; right side window
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 0)
           (window-parameters
            . ((mode-line-format
                . (" "
                   mode-line-buffer-identification)))))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ;; bottom buffer (NOT side window)
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-at-bottom)
           (window-parameters . ((no-other-window . t))))
          ;; ("\\*WordNet.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-right)
          ;;  (slot . 0)
          ;;  (window-width . 0.4)
          ;;  )
          ("\\*.*\\([^E]eshell\\|shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . 0.2)
           ;; (mode . '(eshell-mode shell-mode))
           )))

  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (global-set-key (kbd "s-q") #'window-toggle-side-windows)
  (global-set-key (kbd "C-c 2") #'window-toggle-side-windows)
  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)
#+end_src

#+RESULTS:
| visual-line-mode |

*** window-layout history

Waiting for confirmation before tangling.

#+begin_src emacs-lisp :tangle nil

  (use-package winner
    :hook (after-init-hook . winner-mode)
    :bind (("s-S-<left>" . winner-redo)
           ("s-S-<right>" . winner-undo)))

#+end_src

** buffer switch

#+begin_src emacs-lisp

  ;; between buffers

  (global-set-key (kbd "s-i") #'ibuffer)
  (global-set-key (kbd "s-<left>") #'previous-buffer)
  (global-set-key (kbd "s-<right>") #'next-buffer)
  (global-set-key (kbd "C-x <return> r")
                  ;; originally bound to
                  ;; revert-buffer-with-coding-system
                  #'revert-buffer)

  ;; inside a tab

  (setq aw-keys
        (list ?a ?s ?d ?f ?j ?k ?l))

  (global-set-key (kbd "χ") #'other-window)
  (global-set-key (kbd "H-s") #'delete-other-windows)

  ;; new tab starts with scratch buffer

  (setq tab-bar-new-tab-choice "*scratch*")

#+end_src

#+RESULTS:
: *scratch*

** tab-bar

#+begin_src emacs-lisp

  (use-package tab-bar
    :init
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
    (setq tab-bar-close-tab-select 'recent)
    (setq tab-bar-new-tab-choice t)
    (setq tab-bar-new-tab-to 'right)
    (setq tab-bar-position nil)
    (setq tab-bar-show nil)
    (setq tab-bar-tab-hints nil)
    (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
    :config
    (tab-bar-mode -1)
    (tab-bar-history-mode -1))

  (defun prot-tab--tab-bar-tabs ()
    "Return a list of `tab-bar' tabs, minus the current one."
    (mapcar (lambda (tab)
              (alist-get 'name tab))
            (tab-bar--tabs-recent)))

  (defun prot-tab-select-tab-dwim ()
      "Do-What-I-Mean function for getting to a `tab-bar' tab.
  If no other tab exists, create one and switch to it.  If there is
  one other tab (so two in total) switch to it without further
  questions.  Else use completion to select the tab to switch to."
      (interactive)
      (let ((tabs (prot-tab--tab-bar-tabs)))
        (cond ((eq tabs nil)
               (tab-new))
              ((eq (length tabs) 1)
               (tab-next))
              (t
               (tab-bar-switch-to-tab
                (completing-read "Select tab: " tabs nil t))))))

  (defun prot-tab-tab-bar-toggle ()
    "Toggle `tab-bar' presentation."
    (interactive)
    (if (bound-and-true-p tab-bar-mode)
        (progn
          (setq tab-bar-show nil)
          (tab-bar-mode -1))
      (setq tab-bar-show t)
      (tab-bar-mode 1)))

  (defconst tab-leader "C-x t")

  (general-create-definer tab-leader-def
    :prefix tab-leader)

  ;; global hyper leader def
  (tab-leader-def
    "n" 'tab-bar-new-tab
    "r" 'tab-bar-rename-tab
    "k" 'tab-bar-close-tab
    "t" 'prot-tab-tab-bar-toggle
    "<tab>" 'prot-tab-select-tab-dwim)

  (global-set-key (kbd "C-x t t") #'prot-tab-select-tab-dwim)
#+end_src

** kill buffer
#+begin_src emacs-lisp

  (defun prot-simple-kill-buffer-current (&optional arg)
    "Kill current buffer or abort recursion when in minibuffer.
  With optional prefix ARG (\\[universal-argument]) delete the
  buffer's window as well."
    (interactive "P")
    (if (minibufferp)
        (abort-recursive-edit)
      (kill-buffer (current-buffer)))
    (when (and arg
               (not (one-window-p)))
      (delete-window)))

  (global-set-key (kbd "s-c") #'prot-simple-kill-buffer-current)
  (global-set-key (kbd "s-C") #'(lambda ()
                                  (interactive)
                                  (prot-simple-kill-buffer-current 1)))

#+end_src

** buffer naming

#+begin_src emacs-lisp

  (global-set-key (kbd "C-c b r") #'rename-buffer)
#+end_src

#+RESULTS:
: rename-buffer

* movement

In buffer or across buffers.
** avy
#+begin_src emacs-lisp

  (use-package avy
    :bind (("M-l" . avy-goto-line)))

  (global-set-key (kbd "H-d") #'avy-goto-char-2)
  (global-set-key (kbd "H-f") #'avy-goto-char)

#+end_src

jump to left parenthesis/check parens:

#+begin_src emacs-lisp ()

  (global-set-key (kbd "s-9") #'(lambda () (interactive) (avy-goto-char ?\()))
  (global-set-key (kbd "s-(") #'check-parens)

#+end_src

* project


** version control

#+begin_src emacs-lisp

  (use-package magit
    :bind (("C-c g" . magit))
  )
#+end_src

** projectile

#+begin_src emacs-lisp

  (use-package projectile)
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+end_src

integration with helm:

#+begin_src emacs-lisp

   (use-package helm-projectile
     :config
     (progn
       (helm-projectile-on)
       ))

#+end_src

** dumb-jump

#+begin_src emacs-lisp

  (use-package dumb-jump
    :config
    (progn
      (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
      (setq dumb-jump-debug t)
      (setq dumb-jump-aggressive t)
      (setq dumb-jump-selector 'helm)
      ))

#+end_src

* dired

*** basic

#+begin_src emacs-lisp

  (use-package dired
    :straight nil
    :ensure nil
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-AGFhlv --group-directories-first --time-style=long-iso")
    (setq dired-dwim-target t))

#+end_src

#+begin_src emacs-lisp

  (add-hook 'dired-mode
            #'(lambda ()
                (progn
                  (dired-hide-details-mode +1))))
#+end_src

*** TODO improve
- hide-detail not working
- pipe to shell, group operation

#+begin_src emacs-lisp

  (use-package dired-subtree
    :after dired
    :config
    (progn
      (setq dired-subtree-use-backgrounds nil)
      )
    :bind
    (:map dired-mode-map
          ("<tab>" . dired-subtree-toggle)
          ("C-<tab>" . dired-subtree-cycle)
          ))
#+end_src


#+begin_src emacs-lisp

  (use-package peep-dired
    :bind
    (:map dired-mode-map
     ("`" . peep-dired)
     ))
#+end_src


#+begin_src emacs-lisp

  (use-package dired-filter
    :bind
      (:map dired-mode-map
      ("/" . dired-filter-mark-map)
      )
  )
#+end_src

*** keybinding
The default '^' for =dired-up-directory= feels a bit clumsy.  For such
reason, ';' is binded to the same function in dired-mode using
general.el.

#+begin_src emacs-lisp
  (require 'general)

  (general-define-key
   :keymaps 'dired-mode-map
   ";" #'dired-up-directory
   )

#+end_src

* org

#+begin_src emacs-lisp

  (use-package org
    :config
    (progn
      (setq org-ellipsis " ▾"
            org-hide-emphasis-markers t
            org-imenu-depth 7
            )
      (local-unset-key (kbd "C-'"))
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))))

#+end_src

** appearance

#+begin_src emacs-lisp

(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(add-hook 'org-mode-hook #'org-indent-mode)
#+end_src

** refile
#+begin_src emacs-lisp
  (setq +personal-org-roam-files+ (apply (function append)
				  (mapcar
				   (lambda (directory)
					  (directory-files-recursively directory org-agenda-file-regexp))
				      '("~/org-roam/"))))

  (setq org-refile-targets
	'((nil :maxlevel . 5)
	  (org-agenda-files :maxlevel . 5)
	  (+personal-org-roam-files+ :maxlevel . 5)
	  )
	;; Without this, completers like ivy/helm are only given the first level of
	;; each outline candidates. i.e. all the candidates under the "Tasks" heading
	;; are just "Tasks/". This is unhelpful. We want the full path to each refile
	;; target! e.g. FILE/Tasks/heading/subheading
	org-refile-use-outline-path 'file
	org-outline-path-complete-in-steps nil)
#+end_src

** the todo-keywords cycle
Track state changes.
+ ! :: timestamp 
+ @ :: timestamp with note

#+begin_src emacs-lisp
  (setq org-todo-keywords
	'((sequence "MAYBE(m@)" "TODO(t)" "IN-PROGRESS(i@)" "STUCK(s@/@)" "|" "DONE(d@)" "CANCELLED(c@)")
	  (sequence "REPORT(r)" "BUG(b/@)" "KNOWNCAUSE(k@)" "|" "FIXED(f)")
	  ))
#+end_src


#+begin_src emacs-lisp
  (setq org-stuck-projects
	;; identify a project with TODO keywords/tags
	;; identify non-stuck state with TODO keywords
	;; identify non-stuck state with tags
	;; regexp match non-stuck projects
	'("-moyu&-MAYBE" ("TODO" "IN-PROGRESS" "BUG" "KNOWNCAUSE") nil ""))
#+end_src

** export

*** disable toc by default

#+begin_src emacs-lisp

  (setq org-export-with-toc nil)
#+end_src

*** latex classes

temporary: yanked from
http://emacs-fu.blogspot.com/2009/10/writing-presentations-with-org-mode-and.html
which improves upon
[[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg17712.html]]

#+begin_src emacs-lisp
  ;; allow for export=>beamer by placing

  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-latex-classes)
    (setq org-latex-classes nil))
  (add-to-list 'org-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n          
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")
     
       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"
     
       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


#+end_src

** the sidebar

#+begin_src emacs-lisp

  (use-package org-sidebar)

  (defhydra org-sidebar (org-mode-map "C-c l")
    "sidebar"
    ("t" #'org-sidebar-tree-toggle "tree")
    ("s" #'org-sidebar-toggle "default sidebar")
    )
#+end_src

** babel
*** basic settings

#+begin_src emacs-lisp

  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
#+end_src

#+RESULTS:
: current-window

*** languages

Include languages: 
#+begin_src emacs-lisp

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (shell . t)
   (java . t)
   (C . t)
   (clojure . t)
   (js . t)
   (ditaa . t)
   (dot . t)
   (org . t)
   (latex . t)
   (haskell . t)
   (ditaa . t)
   ))

#+end_src

Set command for python (Ubuntu 20.04 symlinks python to python2.7, so
the default settings calls python2.7).
#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

#+begin_src python :results output :tangle nil

import sys
print(sys.version)
#+end_src

** latex
#+begin_src emacs-lisp
(use-package auctex
  :defer t)

(use-package cdlatex
  :hook (org-mode . turn-on-org-cdlatex))
#+end_src

*** TODO rewrite clear cache
#+begin_src emacs-lisp
(defun langou/org-latex-delete-cache () (interactive)
       (delete-directory "~/.emacs.d/.local/cache/org-latex" :RECURSIVE t))
#+end_src

** org-roam

#+begin_src emacs-lisp
  (use-package org-roam
    :commands org-roam-mode
    :init (add-hook 'after-init-hook 'org-roam-mode)
    :config
    (progn
      ;; all subdirectories of org-roam-directory are considered part of
      ;; org-roam regardless of level of nesting.
      (setq org-roam-directory "~/org-roam")
      (setq org-roam-tag-sources
            (list
             'prop
             'last-directory)))
    :bind (
           ("C-c r t" . org-roam-tag-add)
           ))
#+end_src

#+begin_src emacs-lisp

  (defhydra roam (global-map "C-c r")
    "Org Roam"
    ("d" #'(lambda () (interactive)
             (dired org-roam-directory))
     "visit org-roam-directory")
    ("f" #'org-roam-find-file
     "find-file")
    ("x" #'org-roam-dailies-capture-today
     "capture today")
    ("j" #'org-roam-dailies-today
     "visit today")
    ("i" #'org-roam-insert
     "insert")
    ("c" #'org-roam-build-cache
     "build cache")
    )

#+end_src

#+begin_src emacs-lisp
(use-package org-roam-server
  :ensure t
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))
#+end_src

For 'org-roam-dalies' to work, several variables should be set.  The
'org-roam-dailies-directory' is by default understood as subdirectory
of the root 'org-roam-directory'.

It's importance to notice that org-roam's templating system is /not/
compatible with regular 'org-capture'. In fact, improvment have been
made to allow string prefilling:

#+begin_quote
   In org-roam templates, the ‘${var}’ syntax allows for the expansion
of variables, stored in ‘org-roam-capture--info’.  For example, during
‘org-roam-insert’, the user is prompted for a title.  Upon entering a
non-existent title, the ‘title’ key in ‘org-roam-capture--info’ is set
to the provided title.  ‘${title}’ is then expanded into the provided
title during the org-capture process.  Any variables that do not contain
strings, are prompted for values using ‘completing-read’.
#+end_quote

Fuzzy search 'org roam template' in =describe variable= for customizable
template brought with org-roam.

#+begin_src emacs-lisp

  (setq org-roam-dailies-directory "daily/")

  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry
           #'org-roam-capture--get-point
           "* %?"
           :file-name "daily/%<%Y-%m-%d>"
           :head "#+title: %<%Y-%m-%d>\n\n")))
#+end_src

** org-capture
[2020-12-24 四] A weired phenomena that I just found is that the
result of using defvar and using string for filename directly is
different!  If I use defvar after =file+headline=, the filename is
understood as a file in the relative path and something like
=~/vanilla/just-for-fun.org= is created (clearly the evaluation
happens in the org file in =~/vanilla=. However, if a string
="just-for-fun.org"= is given instead, Emacs understands it as a file
in my org-directory.

   #+begin_src emacs-lisp
     (defvar +org-capture-journal-file+ "journal.org")
     (defvar +org-capture-todo-file+ "todo.org")
     (defvar +org-capture-notes-file+ "notes.org")
     (defvar +org-capture-just-for-fun-file+ "just-for-fun.org")

     ;;;; org-journal
     (global-set-key (kbd "C-c j") #'(lambda ()
                                       (interactive)
                                       (find-file
                                        (concat org-directory "/journal.org"))))

     (global-set-key (kbd "C-c c") #'org-capture)
     (global-set-key (kbd "H-c") #'org-capture)

     (setq org-capture-templates
             '(("t" "Personal todo" entry
                (file+headline "todo.org" "Inbox")
                "* TODO %?\n%i" :prepend t)

               ("n" "Personal notes" entry
                (file+headline "notes.org" "Inbox")
                "* %U %?\n%i\n%a" :prepend t)

               ("f" "Maybe it would be fun someday..." entry
                (file+headline "just-for-fun.org" "Inbox")
                "* MAYBE %U %?" :prepend t)

               ;; declare root node j
               ("j" "Journal")

               ("ja" "Journal arbitrary recording" entry
                (file+olp+datetree "journal.org")
                "* %?\n%U\n%i" :tree-type week)

               ("jc" "journal clock into something new" entry
                (file+olp+datetree "journal.org")
                "* %?" :clock-in t :clock-keep t :tree-type week)

               ("jn" "journal edit the task currently clocked in" plain
                (clock) "%?" :unnarrowed t)

               ("r" "read later" checkitem
                (file+headline "read-later.org" "Inbox")
                "[ ] %? ")

               ("b" "bug" entry
                (file+headline "bug.org" "Inbox")
                "* BUG %^{header}\n%U\n#+begin_src\n\n%i\n\n#+end_src\n%?")

               ("v" "vocabularies" entry
                (file+headline "voc.org" "inbox")
                "* %<%Y-%m-%d %H:%M:%S>\n:PROPERTIES:\n:ANKI_NOTE_TYPE: Basic\n:ANKI_DECK: langou gre\n:END:\n** Front\n%?\n** Back\n%i\n")
               ))
   #+end_src

** org-agenda
#+begin_src emacs-lisp
(setq org-agenda-files (apply (function append)
			        (mapcar
			         (lambda (directory)
				        (directory-files-recursively directory org-agenda-file-regexp))
			            '("~/org/"))))
#+end_src

** habit
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit)
  (global-set-key (kbd "s-a") #'org-agenda)
#+end_src

** completion 

#+begin_src emacs-lisp

  (add-to-list 'org-modules 'org-tempo)
  (setq org-structure-template-alist
    '(("a" . "export ascii\n")
      ("c" . "center\n")
      ("C" . "comment\n")
      ("e" . "src emacs-lisp\n")
      ("cp" . "src cpp\n")
      ("py" . "src python\n")
      ("sh" . "src shell")
      ("E" . "export")
      ("h" . "export html\n")
      ("l" . "export latex\n")
      ("q" . "quote\n")
      ("s" . "src")
      ("v" . "verse\n")))
#+end_src

#+begin_example
((a . export ascii
) (c . center
) (C . comment
) (e . src emacs-lisp
) (cp . src cpp
) (py . src python
) (sh . src shell) (E . export) (h . export html
) (l . export latex
) (q . quote
) (s . src) (v . verse
))
#+end_example
** pdf
#+begin_src emacs-lisp

(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))

(use-package org-noter)

(use-package org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

** misc
*** TODO shortkey conflict 
shortkey of org-mark-ring-goto conflicts with yasnippet.
* miscellaneous

** set debug on error, load custom

#+begin_src emacs-lisp

  (setq debug-on-error nil)
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)

#+end_src

** default browser
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
#+end_src

** command-log

  #+begin_src emacs-lisp

    (use-package command-log-mode)
  #+end_src
  
** ligature
#+begin_src emacs-lisp
    (defconst lisp--prettify-symbols-alist
	'(("lambda"  . ?λ)))

    (add-hook 'lisp-mode-hook #'(lambda () (interactive)
				 (prettify-symbols-mode +1)))


  (setq python-prettify-symbols-alist
	(list
	 '("lambda"  . ?λ)
	 '("**2" . ?²)
	 '("sum" . ?∑)
	 '("sigma" . ?σ)
	 '("mu" . ?μ)
	 '("theta" . ?θ)
	 '("_0" . ?₀)
	 '("_1" . ?₁)
	 '("_2" . ?₂)
	 ))
#+end_src

** bookmarks

#+begin_src emacs-lisp

  (global-set-key (kbd "s-m") #'bookmark-set)

#+end_src

In addition, s-<return> is bound to =helm-filtered-bookmarks= in [[*helm]].

** dictionary and web search

#+begin_src emacs-lisp

  (use-package search-web)
  (use-package wordnut)
  (setq search-web-engines
        '(
          ("duck" "https://duckduckgo.com/?q=%s" nil)
          ("github" "https://github.com/search?q=%s" nil)
          ("google" "http://www.google.com/search?q=%s" nil)
          ("google scholar" "https://scholar.google.co.jp/scholar?q=%s" nil)
          ("youtube" "http://www.youtube.com/results?search_type=&search_query=%s&aq=f" External)
          ("emacswiki" "http://www.google.com/cse?cx=004774160799092323420%%3A6-ff2s0o6yi&q=%s&sa=Search" nil)
          ("wikipedia en" "http://www.wikipedia.org/search-redirect.php?search=%s&language=en" nil)
          ("stackoveflow en" "http://stackoverflow.com/search?q=%s" nil)
          ))

  (defhydra define (global-map "s-d")
    "define"
    ("w" wordnut-search "wordnet")
    ("i" search-web "web search")
    ("m" man "man")
    )

#+end_src

** transparency

Interactively toggle transparency in winframe.
#+begin_src emacs-lisp

  (defun transparency (value)
    "sets the transparency of the frame window. 0=transparent/100=opaque"
    (interactive "ntransparency value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

Transparency at start:

#+begin_src emacs-lisp

  (defvar +frame-transparency+ '(95 95))
  (add-to-list 'default-frame-alist `(alpha . ,+frame-transparency+))

#+end_src

** cursor in =-nw= mode

currently disabled as I'm not using evil.
#+begin_src emacs-lisp :tangle nil

  (unless (display-graphic-p)
          (require 'evil-terminal-cursor-changer)
          (evil-terminal-cursor-changer-activate) ; or (etcc-on)
          )
#+end_src

** focused editing

#+begin_src emacs-lisp

  (use-package olivetti
    :config
    (progn
      ;; occupies 7/10 of the window width  
      (setq-default olivetti-body-width 0.7)
      )
    :bind (("C-c f e" . olivetti-mode)))

#+end_src

** expand-region.el

#+begin_src emacs-lisp

  (use-package expand-region
    :config
    (progn
      (global-set-key (kbd "C-=") #'er/expand-region)
      ))
#+end_src

** remove unused UI components

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (setq use-file-dialog nil)
  (setq use-dialog-box t)               ; only for mouse events
  ;; (setq inhibit-splash-screen t)
#+end_src

** copy filename

From Doom Emacs. Naming is altered to be consistent with Emacs terms
(yank -> save-to-king-ring).

#+begin_src emacs-lisp

  (defun +default/save-to-king-ring-buffer-filename ()
    "Copy the current buffer's path to the kill ring."
    (interactive)
    (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
        (message (kill-new (abbreviate-file-name filename)))
      (error "Couldn't find filename in current buffer")))

  (global-set-key (kbd "C-c k f")  #'+default/save-to-king-ring-buffer-filename)
#+end_src

** make all prompts y or n

#+begin_src emacs-lisp

(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** yaml

#+begin_src emacs-lisp

(use-package yaml-mode)
#+end_src

** integration with pywal

#+begin_src emacs-lisp :tangle nil

  (straight-use-package
   '(theme-magic
     :host github
     :repo "jcaw/theme-magic"
     :branch "wal-theme-template"))

  (straight-use-package
   '(xresources-theme
     :host github
     :repo "cqql/xresources-theme"))
#+end_src

* lsp

** basic

- find definitions :: 'C-x 4 .', 'M-.',  'C-x 5 .'
- find references :: 'M-?'
- definition glance (lsp-ui) :: 'ρ h g'

#+begin_src emacs-lisp

  (use-package lsp-mode)

  (use-package flycheck)

  (use-package lsp-ui
    :after lsp-mode
    :demand flycheck
    )

  (use-package lsp-python-ms
    :init (setq lsp-python-ms-auto-install-server t
                read-process-output-max 1048576)
    :hook (python-mode . (lambda ()
                           (require 'lsp-python-ms)
                           (lsp))))

#+end_src

** keybinding

#+begin_src emacs-lisp

  (setq lsp-keymap-prefix "ρ")
  (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)

#+end_src

** ui tweaking

#+begin_src emacs-lisp

  (setq lsp-ui-doc-position 'bottom)
  (setq lsp-ui-doc-use-childframe nil)
  (setq lsp-ui-doc-delay 0)
  (setq lsp-ui-sideline-show-diagnostics t)
  (setq lsp-ui-sideline-show-hover nil)
  (setq lsp-eldoc-render-all nil)

#+end_src

** scroll -> freeze fix

Whenever I try to scroll down (using mouse) until the bottom in a
lsp-ui-doc childframe, the cpu usage rises to 100% and Emacs freezes.

#+begin_src emacs-lisp

  (setq
   mouse-wheel-scroll-amount
   '(1
     ((shift) . 1))
   mouse-wheel-progressive-speed nil)

  (general-define-key
   :maps 'lsp-mode-map
   "C-c u i" #'lsp-ui-imenu
   "C-c d" #'lsp-ui-doc-focus-frame)
#+end_src

* music
** basic setup for emms

- s :: stop
- n :: next

#+begin_src emacs-lisp
  (use-package emms
    :config
    (progn
      (emms-all)
      (emms-default-players)
      (setq emms-source-file-default-directory "~/Music")
      (setq emms-player-mplayer-parameters
	      '("-slave" "-quiet" "-really-quiet" "-novideo"))))

  (global-set-key (kbd "C-c m m") #'emms)
  (global-set-key (kbd "C-c m p") #'emms-add-playlist)
#+end_src

** TODO improve config
+ block mplayer from poping up

* e-books and documents

** pdf

#+begin_src emacs-lisp
  (pdf-tools-install)
  (setq pdf-view-midnight-colors
        '("#cccccc" . "#000000"))
#+end_src

#+begin_src emacs-lisp
  (general-define-key
   :keymaps 'pdf-view-mode-map
   "o" #'pdf-outline
   "j" #'pdf-view-next-line-or-next-page
   "k" #'pdf-view-previous-line-or-previous-page
   "]" #'pdf-view-next-page-command
   "[" #'pdf-view-previous-page-command
   "/" #'pdf-occur)
#+end_src

frequently used commands for movement:
- f
- m and '
- /
- SPC S-SPC

** TODO epub, djvu, mobi

* shell and term

** vterm

#+begin_src emacs-lisp

  (use-package vterm)
#+end_src

#+begin_src emacs-lisp

  (use-package vterm-toggle
    :bind
    ("s-v" . vterm-toggle)
    ("s-V" . vterm-toggle-cd)
    )
#+end_src

** eshell

*** eshell toggle

#+begin_src emacs-lisp

  (use-package eshell-toggle)
  (global-set-key (kbd "s-e") #'eshell-toggle)
#+end_src

*** git prompt

#+begin_src emacs-lisp

  (use-package eshell-git-prompt
    :config
    (progn
      (eshell-git-prompt-use-theme 'robbyrussell)
      ))
#+end_src

*** keybinding

#+begin_src emacs-lisp

  (global-set-key (kbd "s-e") #'eshell)

#+end_src

[[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell pop up window]]

#+begin_src emacs-lisp :tangle nil
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (global-set-key (kbd "s-e") 'eshell-here)

  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))
#+end_src

*** PATH

#+begin_src emacs-lisp

  (setenv "PATH"
    (concat
     ;; manually added
     "/usr/local/cbc/bin" ";"
     "~/.local/bin" ";"
     (getenv "PATH")			; inherited from OS
     )
  )

#+end_src

*** alias

The 'alias' command in eshell defines aliases sotre in
=eshell-alias-file=, which is inside the =user-emacs-directory= by
default.

#+begin_quote

   Note that unlike aliases in Bash, arguments must be handled
explicitly.  Typically the alias definition would end in ‘$*’ to pass
all arguments along.  More selective use of arguments via ‘$1’, ‘$2’,
etc., is also possible.  For example, ‘alias mcd 'mkdir $1 && cd $1'’
would cause ‘mcd foo’ to create and switch to a directory called
‘foo’.
#+end_quote

* modeline config

[[https://occasionallycogent.com/custom_emacs_modeline/index.html][A tutorial]]
[[info:emacs#Mode Line][info:emacs#Mode Line]]
[[help:mode-line-format]]
** the default

CS:CH-FR BUF  POS LINE (MAJOR MODE)
+ CS :: coding system.
+ ':' :: eol convention. Unix by default (on my XPS15 9500 running
  Linux). One may also choose Mac or DOS.
+ &optional @ :: for emacsclient.
+ CH :: change(?) 
+ '-' :: becomes '@' if the current buffer is on a remote machine.
+ FR :: only appears on text terminals
+ BUFF :: name of buffer.
+ POS :: position in the buffer.
  
#+begin_src emacs-lisp

  (defun mode-line-format-raw ()
    (interactive)

    (setq mode-line-format
            '("%e" mode-line-front-space mode-line-mule-info mode-line-client
              mode-line-modified mode-line-remote
              mode-line-frame-identification
              mode-line-buffer-identification " " mode-line-position
              (vc-mode vc-mode)
              "  " mode-line-modes mode-line-misc-info mode-line-end-spaces)
  ))
#+end_src

#+begin_src emacs-lisp

  (use-package diminish)
  (diminish 'ivy-mode)
  (diminish 'auto-revert-mode)
  (diminish 'yas-minor-mode)
  (diminish 'org-cdlatex-mode)
  (diminish 'which-key-mode)
  (diminish 'org-roam-mode)
  (diminish 'company-mode)
#+end_src

** doom modeline

#+begin_src emacs-lisp 

  (use-package doom-modeline
    ;; :init (doom-modeline-mode 1)
    :config
    (progn
      (setq doom-modeline-height 15)))

#+end_src

* languages

#+begin_src emacs-lisp
(global-set-key (kbd "H-r") #'compile)
#+end_src

** lisp-general

#+begin_src emacs-lisp

  (use-package lispy)
  (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1)))
  (add-hook 'racket-mode-hook (lambda () (lispy-mode 1)))
#+end_src

#+begin_src emacs-lisp

  (use-package paren-face)
  (add-hook 'emacs-lisp-mode-hook (lambda () (paren-face-mode 1)))
#+end_src

** racket

#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** cmake

#+begin_src emacs-lisp
  (use-package cmake-mode)
#+end_src

** C/C++

*** cpputils-cmake

#+begin_src emacs-lisp :tangle nil

  (use-package cpputils-cmake)

  (add-hook 'c-mode-common-hook
            (lambda ()
              (if (derived-mode-p 'c-mode 'c++-mode)
                  (cppcm-reload-all)
                )))
  ;; OPTIONAL, somebody reported that they can use this package with Fortran
  (add-hook 'c90-mode-hook (lambda () (cppcm-reload-all)))
  ;; OPTIONAL, avoid typing full path when starting gdb
  (global-set-key (kbd "C-c C-g")
   '(lambda ()(interactive) (gud-gdb (concat "gdb --fullname " (cppcm-get-exe-path-current-buffer)))))
  ;; OPTIONAL, some users need specify extra flags forwarded to compiler
  (setq cppcm-extra-preprocss-flags-from-user '("-I/usr/src/linux/include" "-DNDEBUG"))
#+end_src

* EXWM
:PROPERTIES:
:header-args: :tangle nil
:END:

** keybinding

Most keys defined in [[*window and buffer]] are configured as prefix-keys
in exwm windows.  s-<num> switches to <num> th workspace, although
workspace is never used with single monitor (of xps15).

C-p, C-n, C-b, C-f, C-a, C-e are set to send keys to exwm-windows
according to Emacs keybindings (similar to what happens in MacOS and
tweaked gnome).

Firefox provides caret-mode for keyboard-driven text-selection
(Shift + Movement to select). Together with =M-w= configured to send =C-c=
to the exwm-windows, a relatively consistent experience of copying is
achieved.

#+begin_src emacs-lisp 
  (use-package exwm
    :config
    (progn
      (setq exwm-workspace-number 3)
      (setq exwm-input-prefix-keys
            `(?\C-x
              ?\s-o ;; switch-to-buffer
              ?\s-i ;; ibuffer
              ?\s-j ;; window switch
              ?\s-c ;; kill window
              ?\s-C ;; kill buffer and window(if not single)
              ?\s-k ;; window switch
              ?\s-v ;; vterm
              ?\s-s ;; single-window-toggle
              ?\s-e ;; eshell
              ?\s-q ;; toggle side windows
              ?\s-t ;; toggle touchpad
              ?\s-d ;; helm-wordnut
              ?\C-u ;; general command
              ?\C-h ;; help
              ?\M-x
              ?\M-&
              ?\M-:
              ?\H-c ;; org-capture
              ?\H-s ;; kill other windows
              ?\C-\ ))
      (setq exwm-input-global-keys
            `(([?\s-r] . exwm-reset)
              ([?\s-w] . exwm-workspace-switch)
              ([?\s-\;] . (lambda (command)
                            (interactive (list (read-shell-command "$ ")))
                            (start-process-shell-command command nil command)))
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-%d" i)) .
                            (lambda ()
                              (interactive)
                              (exwm-workspace-switch-create ,i))))
                        (number-sequence 0 2))))
      (exwm-input-set-simulation-keys
       '(([?\C-b] . left)
         ([?\C-f] . right)
         ([?\C-p] . up)
         ([?\C-n] . down)
         ([?\C-a] . home)
         ([?\C-e] . end)
         ([?\M-w] . [?\C-c])
         ;; ([?\M-b] . [?\C-?\<left>])
         ;; ([?\M-f] . [?\C-?\<left>])
         ))
      (setq exwm-workspace-warp-cursor t
            mouse-autoselect-window t
            focus-follows-mouse t)
      ;; (exwm-enable)
      ))
#+end_src

Ocassionly, key-sequences intercepted by Emacs can be send after C-q.
s-SPC runs #'counsel-linux-app and s-<tab> toggles tab selection.

#+begin_src emacs-lisp

  ;; After C-q, send key to the window 
  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
  (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)

#+end_src

** window configuring

#+begin_src emacs-lisp

  (defun efs/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun efs/exwm-init-hook ()
    ;; Make workspace 1 be the one where we land at startup
    (exwm-workspace-switch-create 1)

    ;; Start the Polybar panel
    (exwm-outer-gaps-mode)
    (efs/start-panel)

    ;; Launch apps that will run in the background
    ;; (efs/run-in-background "dunst")
    ;; (efs/run-in-background "nm-applet")
    ;; (efs/run-in-background "pasystray")
    ;; (efs/run-in-background "blueman-applet")

  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("Firefox" (exwm-workspace-rename-buffer (format "Firefox: %s" exwm-title)))
      )))

  ;; This function isn't currently used, only serves as an example how to
  ;; position a window
  (defun efs/position-window ()
    (let* ((pos (frame-position))
	   (pos-x (car pos))
	    (pos-y (cdr pos)))
      (exwm-floating-move (- pos-x) (- pos-y))))

  (defun efs/configure-window-by-class ()
    (interactive)
    (pcase exwm-class-name
      ("electron-ssr" (exwm-floating-toggle-floating))))

  ;; When EXWM starts up, do some extra confifuration
  (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

  ;; When window "class" updates, use it to set the buffer name
  (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

  ;; When window title updates, use it to set the buffer name
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  ;; Configure windows as they're created
  (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

#+end_src

** useless gaps

[[https://github.com/lucasgruss/exwm-outer-gaps][the repo]] hasn't yet been submitted to MELPA.

#+begin_src emacs-lisp

  (straight-use-package
   '(exwm-outer-gaps :host github :repo "lucasgruss/exwm-outer-gaps")
   )

  (setq exwm-outer-gaps-width [25 25 25 25])
  (global-set-key (kbd "H-G") #'exwm-outer-gaps-mode)
  (global-set-key (kbd "C-c 1") #'exwm-outer-gaps-mode)

#+end_src

** desktop environment

Get more decent.

- Volume: amixer
- Brightness: brightnessctl
- Screenshot: scrot
- Screenlock: slock
- Keyboard backlight: upower
- Wifi and bluetooth: TLP
- Music: playerctl

#+begin_src emacs-lisp

  (use-package desktop-environment)
  (desktop-environment-mode)
#+end_src

** workspaces and monitors
Make sure xrandr update refresh EXWM frames.
Assign workspaces to monitors.
#+begin_src emacs-lisp
  (require 'exwm-randr)
  (setq exwm-randr-workspace-monitor-plist '(1 "DP-1-2" 1 "DP-2" 1 "DP-1-1" 1 "DP-1"))
  (exwm-randr-enable)
#+end_src

#+begin_src emacs-lisp
  (defun efs/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun efs/update-displays ()
    (efs/run-in-background "autorandr --change --force")
    (message "Display config: %s"
	     (string-trim (shell-command-to-string "autorandr --current"))))

  (add-hook 'exwm-randr-screen-change-hook #'efs/update-displays)
  (efs/update-displays)

#+end_src

** wallpaper

#+begin_src emacs-lisp :tangle nil :eval never 

(defun wallpaper--scaling ()
  "Return the wallpaper scaling style to use."
  (cl-case wallpaper-scaling
    (scale "--bg-scale ")
    (max "--bg-max ")
    (fill "--bg-fill ")
    (tile "--bg-tile ")
    (center "--bg-center ")))
#+end_src

#+begin_src emacs-lisp

  (unless (executable-find "feh")
    (display-warning 'wallpaper "External command `feh' not found!"))

  ;; This is an example `use-package' configuration
  ;; It is not tangled into wallpaper.el
  (use-package wallpaper
    :ensure t
    :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
           (after-init . wallpaper-cycle-mode))
    :custom ((wallpaper-cycle-single t)
             (wallpaper-scaling 'fill)
             (wallpaper-cycle-interval 45)
             (wallpaper-cycle-directory "~/Pictures/Wallpapers")))

#+end_src

** polybar

#+begin_src emacs-lisp

  (defvar efs/polybar-process nil
    "Holds the process of the running Polybar instance, if any")

  (defun efs/kill-panel ()
    (interactive)
    (when efs/polybar-process
      (ignore-errors
        (kill-process efs/polybar-process)))
    (setq efs/polybar-process nil))

  (defun efs/start-panel ()
    (interactive)
    (efs/kill-panel)
    (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))

  (defun efs/send-polybar-hook (module-name hook-index)
    (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

  (defun efs/polybar-exwm-workspace ()
    (pcase exwm-workspace-current-index
      (0 "")
      (1 "")
      (2 "")
      (3 "")
      (4 "")))

  (defun efs/send-polybar-exwm-workspace ()
    (efs/send-polybar-hook "exwm-workspace" 1))

  (defun langou/toggle-touchpad ()
    (interactive)
    (start-process-shell-command "exec" nil "exec ~/.dwm/toggleTouchpad.sh"))

  (global-set-key (kbd "s-t") #'langou/toggle-touchpad)

  ;; Update panel indicator when workspace changes
  (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

#+end_src

#+begin_src conf :tangle nil

  ; Docs: https://github.com/polybar/polybar
  ;==========================================================

  [settings]
  screenchange-reload = true

  [global/wm]
  margin-top = 0
  margin-bottom = 0

  [colors]
  background = #f0232635
  background-alt = #576075
  foreground = #A6Accd
  foreground-alt = #555
  primary = #ffb52a
  secondary = #e60053
  alert = #bd2c40
  underline-1 = #c792ea

  [bar/panel]
  width = 100%
  height = 35
  offset-x = 0
  offset-y = 0
  fixed-center = true
  enable-ipc = true

  background = ${colors.background}
  foreground = ${colors.foreground}

  line-size = 2
  line-color = #f00

  border-size = 0
  border-color = #00000000

  padding-top = 5
  padding-left = 1
  padding-right = 1

  module-margin = 1

  font-0 = "Cantarell:size=18:weight=bold;2"
  font-1 = "Font Awesome:size=14;2"
  font-2 = "Material Icons:size=20;5"
  font-3 = "Fira Mono:size=13;-3"

  modules-left = exwm-workspace
  modules-right = cpu temperature battery date

  tray-position = right
  tray-padding = 2
  tray-maxsize = 28

  cursor-click = pointer
  cursor-scroll = ns-resize

  [module/exwm-workspace]
  type = custom/ipc
  hook-0 = emacsclient -e "exwm-workspace-current-index" | sed -e 's/^"//' -e 's/"$//'
  initial = 1
  format-underline = ${colors.underline-1}
  format-padding = 1

  [module/cpu]
  type = internal/cpu
  interval = 2
  format = <label> <ramp-coreload>
  format-underline = ${colors.underline-1}
  click-left = emacsclient -e "(proced)"
  label = %percentage:2%%
  ramp-coreload-spacing = 0
  ramp-coreload-0 = ▁
  ramp-coreload-0-foreground = ${colors.foreground-alt}
  ramp-coreload-1 = ▂
  ramp-coreload-2 = ▃
  ramp-coreload-3 = ▄
  ramp-coreload-4 = ▅
  ramp-coreload-5 = ▆
  ramp-coreload-6 = ▇

  [module/date]
  type = internal/date
  interval = 5

  date = "%a %b %e"
  date-alt = "%A %B %d %Y"

  time = %l:%M %p
  time-alt = %H:%M:%S

  format-prefix-foreground = ${colors.foreground-alt}
  format-underline = ${colors.underline-1}

  label = %date% %time%

  [module/battery]
  type = internal/battery
  battery = BAT0
  adapter = ADP1
  full-at = 98
  time-format = %-l:%M

  label-charging = %percentage%% / %time%
  format-charging = <animation-charging> <label-charging>
  format-charging-underline = ${colors.underline-1}

  label-discharging = %percentage%% / %time%
  format-discharging = <ramp-capacity> <label-discharging>
  format-discharging-underline = ${self.format-charging-underline}

  format-full = <ramp-capacity> <label-full>
  format-full-underline = ${self.format-charging-underline}

  ramp-capacity-0 = 
  ramp-capacity-1 = 
  ramp-capacity-2 = 
  ramp-capacity-3 = 
  ramp-capacity-4 = 

  animation-charging-0 = 
  animation-charging-1 = 
  animation-charging-2 = 
  animation-charging-3 = 
  animation-charging-4 = 
  animation-charging-framerate = 750

  [module/temperature]
  type = internal/temperature
  thermal-zone = 0
  warn-temperature = 60

  format = <label>
  format-underline = ${colors.underline-1}
  format-warn = <label-warn>
  format-warn-underline = ${self.format-underline}

  label = %temperature-c%
  label-warn = %temperature-c%!
  label-warn-foreground = ${colors.secondary}

#+end_src

* save sessions

- desktop-save :: manual save
- desktop-save-mode :: non nil if the /mode/ is enabled
- desktop-change-dir :: save current desktop and reload one saved in
  another directory.
- desktop-revert :: reverts to the desktop /previously reloaded/.
- desktop-path :: list of directories to search for the desktop file.
- desktop-clear :: kills all buffers except internal ones, and clears
  the global variables listed in ‘desktop-globals-to-clear’. Variable
  can be set to preserve some buffers matching certain regexp.

  The =--no-desktop= option can be passed
  so that no saved desktop wouldn't be reloaded.

#+begin_src emacs-lisp

(desktop-save-mode nil)
#+end_src

* eaf

experimental.  By default it override some tools that I've been
familiar with (like pdf-tools).  Only used after manual execution of
code block.

#+begin_src emacs-lisp :tangle nil

  (add-to-list 'load-path "~/vanilla/site-lisp/emacs-application-framework/")
  (require 'eaf)
#+end_src

#+begin_src emacs-lisp :tangle nil :eval never

(use-package eaf
  :custom
  (eaf-browser-continue-where-left-off t)
  :config
  (eaf-setq eaf-browser-enable-adblocker "true")
  (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
#+end_src

* workflow

This is a special section dedicated to describe the ideal workflow
that this configuration seeks to provide. For easier maintenance it
shall not contain any source block to tangle.

** switch buffer

In EXWM, emacs buffer and application presented in X windows are
treated equally in buffer lists.

in =helm-buffer-list=, the list can be quickly narrowed with

- name of the buffer
- major mode via =*[pattern to match major mode]= or =*![pattern to match major mode]=
- directory with =/[pattern to match directory]= or '!' after '/' for negation
- include text via '@[pattern to match text]' or '!' after '@' for negation

#+begin_quote

‘helm-buffers-fuzzy-matching’ turns on fuzzy matching on buffer names, but not
on directory names or major modes.  A pattern starting with "^" disables fuzzy
matching and matches by exact regexp.

#+end_quote

Unfortunately, the content of other applications is not accessible to
emacs. Even for [[*eaf]] buffer, the content of webpage/pdf(?) is not accessible
to helm.

frequently used actions on buffer:
- C-c o :: open in other window
  
** maintenance

Periodic activities that clears whatever impedes progress along a
clean workflow. It remains to observe whether dedicatin into
maintenance could defy the meaning of its own existence.

- bookmark cleaning
- check agenda
- Youtube watche later achive to org
- read-later.org check

** code reading

- peep-dired + dired-subtree :: for brief grasp of file structure
- ? :: take note on file structure
- ;-m :: bookmark
- ? :: capture template for specific code

- s-p f :: helm-projectile-find-file
- s-f d :: rg-dwim
- s-f r :: regexp search in chosen directory

** debug

- ? :: solution from br
- H-c b / C-c c b :: capture bug from command line (requires manual
  selection)

** note taking 

explicate how objects of note-taking are classified and
located/refiled/archived.

* anki

anki-editor provides anki-integration with org-mode.
see [[*org-capture]] for capture-templates creating anki entries.

#+begin_src emacs-lisp

  (use-package anki-editor)
#+end_src

* meta

Automatically tangle /this file/ on save.

#+begin_src emacs-lisp

  (defun efs/org-babel-tangle-config ()
    (when (string-equal (file-name-directory (buffer-file-name))
                        (expand-file-name user-emacs-directory))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))

#+end_src

 
